# ! [doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.30.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.30.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_bounds)]
# ! [deny (private_interfaces)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + PartialEq + From < Self > ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ,) ; } } # [doc (hidden)]
pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct FieldWriter < 'a , REG , const WI : u8 , const O : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , const O : u8 , FI , Safety > FieldWriter < 'a , REG , WI , O , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG >) -> Self { Self { w , _field : marker :: PhantomData , } } } pub struct BitWriter < 'a , REG , const O : u8 , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , const O : u8 , FI , M > BitWriter < 'a , REG , O , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG >) -> Self { Self { w , _field : marker :: PhantomData , } } } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub type W < REG > = raw :: W < REG > ; # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> FI :: Ux { self . bits } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , O , FI , Unsafe > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , O , FI , Safe > ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , const O : u8 , FI = bool > = raw :: BitWriter <'a , REG , O , FI , $ mwv >; impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { self . bits (FI :: Ux :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , REG , const OF : u8 , FI > BitWriter < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } } # [cfg (feature = "rt")]
extern "C" { fn TIMER0 () ; fn UART () ; } # [doc (hidden)]
pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [no_mangle]
pub static __EXTERNAL_INTERRUPTS : [Vector ; 3]
= [Vector { _reserved : 0 } , Vector { _handler : TIMER0 } , Vector { _handler : UART } ,]
; # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "1 - timer0"]
TIMER0 = 1 , # [doc = "2 - uart"]
UART = 2 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 1 => Ok (Interrupt :: TIMER0) , 2 => Ok (Interrupt :: UART) , _ => Err (TryFromInterruptError (())) , } } } # [cfg (feature = "rt")]
# [macro_export]
# [doc = r" Assigns a handler to an interrupt"]
# [doc = r""]
# [doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
# [doc = r" function that will be used as the handler of that interrupt. That function"]
# [doc = r" must have signature `fn()`."]
# [doc = r""]
# [doc = r" Optionally, a third argument may be used to declare interrupt local data."]
# [doc = r" The handler will have exclusive access to these *local* variables on each"]
# [doc = r" invocation. If the third argument is used then the signature of the handler"]
# [doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
# [doc = r" passed to the macro."]
# [doc = r""]
# [doc = r" # Example"]
# [doc = r""]
# [doc = r" ``` ignore"]
# [doc = r" interrupt!(TIM2, periodic);"]
# [doc = r""]
# [doc = r" fn periodic() {"]
# [doc = r#"     print!(".");"#]
# [doc = r" }"]
# [doc = r""]
# [doc = r" interrupt!(TIM3, tick, locals: {"]
# [doc = r"     tick: bool = false;"]
# [doc = r" });"]
# [doc = r""]
# [doc = r" fn tick(locals: &mut TIM3::Locals) {"]
# [doc = r"     locals.tick = !locals.tick;"]
# [doc = r""]
# [doc = r"     if locals.tick {"]
# [doc = r#"         println!("Tick");"#]
# [doc = r"     } else {"]
# [doc = r#"         println!("Tock");"#]
# [doc = r"     }"]
# [doc = r" }"]
# [doc = r" ```"]
macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } } } pub use self :: interrupt :: Interrupt ; # [doc = "APF_AUDIO"]
pub struct APF_AUDIO { _marker : PhantomData < * const () > } unsafe impl Send for APF_AUDIO { } impl APF_AUDIO { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_audio :: RegisterBlock = 0xf000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_audio :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_AUDIO { type Target = apf_audio :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_AUDIO { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_AUDIO") . finish () } } # [doc = "APF_AUDIO"]
pub mod apf_audio { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - The entrypoint to the audio buffer. Write two 16 bit signed values (for the left and right audio channels) here. This will push one value into the 4096 record FIFO that represents the audio buffer."]
pub out : OUT , # [doc = "0x04 - Enable audio playback (reading of the audio buffer) when set to 1. No audio playback otherwise."]
pub playback_en : PLAYBACK_EN , # [doc = "0x08 - Writing 1 to this register will immediately clear the audio buffer."]
pub buffer_flush : BUFFER_FLUSH , # [doc = "0x0c - The current fill level of the audio buffer. The buffer is full when set to `0xFFF`"]
pub buffer_fill : BUFFER_FILL , } # [doc = "OUT (rw) register accessor: The entrypoint to the audio buffer. Write two 16 bit signed values (for the left and right audio channels) here. This will push one value into the 4096 record FIFO that represents the audio buffer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`out`]
module"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "The entrypoint to the audio buffer. Write two 16 bit signed values (for the left and right audio channels) here. This will push one value into the 4096 record FIFO that represents the audio buffer."]
pub mod out { # [doc = "Register `OUT` reader"]
pub type R = crate :: R < OUT_SPEC > ; # [doc = "Register `OUT` writer"]
pub type W = crate :: W < OUT_SPEC > ; # [doc = "Field `out` reader - "]
pub type OUT_R = crate :: FieldReader < u32 > ; # [doc = "Field `out` writer - "]
pub type OUT_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn out (& mut self) -> OUT_W < OUT_SPEC , 0 > { OUT_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The entrypoint to the audio buffer. Write two 16 bit signed values (for the left and right audio channels) here. This will push one value into the 4096 record FIFO that represents the audio buffer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`out::R`](R) reader structure"]
impl crate :: Readable for OUT_SPEC { } # [doc = "`write(|w| ..)` method takes [`out::W`](W) writer structure"]
impl crate :: Writable for OUT_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PLAYBACK_EN (rw) register accessor: Enable audio playback (reading of the audio buffer) when set to 1. No audio playback otherwise.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`playback_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`playback_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`playback_en`]
module"]
pub type PLAYBACK_EN = crate :: Reg < playback_en :: PLAYBACK_EN_SPEC > ; # [doc = "Enable audio playback (reading of the audio buffer) when set to 1. No audio playback otherwise."]
pub mod playback_en { # [doc = "Register `PLAYBACK_EN` reader"]
pub type R = crate :: R < PLAYBACK_EN_SPEC > ; # [doc = "Register `PLAYBACK_EN` writer"]
pub type W = crate :: W < PLAYBACK_EN_SPEC > ; # [doc = "Field `playback_en` reader - "]
pub type PLAYBACK_EN_R = crate :: BitReader ; # [doc = "Field `playback_en` writer - "]
pub type PLAYBACK_EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn playback_en (& self) -> PLAYBACK_EN_R { PLAYBACK_EN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn playback_en (& mut self) -> PLAYBACK_EN_W < PLAYBACK_EN_SPEC , 0 > { PLAYBACK_EN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Enable audio playback (reading of the audio buffer) when set to 1. No audio playback otherwise.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`playback_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`playback_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PLAYBACK_EN_SPEC ; impl crate :: RegisterSpec for PLAYBACK_EN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`playback_en::R`](R) reader structure"]
impl crate :: Readable for PLAYBACK_EN_SPEC { } # [doc = "`write(|w| ..)` method takes [`playback_en::W`](W) writer structure"]
impl crate :: Writable for PLAYBACK_EN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PLAYBACK_EN to value 0"]
impl crate :: Resettable for PLAYBACK_EN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BUFFER_FLUSH (rw) register accessor: Writing 1 to this register will immediately clear the audio buffer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`buffer_flush::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer_flush::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`buffer_flush`]
module"]
pub type BUFFER_FLUSH = crate :: Reg < buffer_flush :: BUFFER_FLUSH_SPEC > ; # [doc = "Writing 1 to this register will immediately clear the audio buffer."]
pub mod buffer_flush { # [doc = "Register `BUFFER_FLUSH` reader"]
pub type R = crate :: R < BUFFER_FLUSH_SPEC > ; # [doc = "Register `BUFFER_FLUSH` writer"]
pub type W = crate :: W < BUFFER_FLUSH_SPEC > ; # [doc = "Field `buffer_flush` reader - "]
pub type BUFFER_FLUSH_R = crate :: BitReader ; # [doc = "Field `buffer_flush` writer - "]
pub type BUFFER_FLUSH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn buffer_flush (& self) -> BUFFER_FLUSH_R { BUFFER_FLUSH_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn buffer_flush (& mut self) -> BUFFER_FLUSH_W < BUFFER_FLUSH_SPEC , 0 > { BUFFER_FLUSH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Writing 1 to this register will immediately clear the audio buffer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`buffer_flush::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer_flush::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BUFFER_FLUSH_SPEC ; impl crate :: RegisterSpec for BUFFER_FLUSH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`buffer_flush::R`](R) reader structure"]
impl crate :: Readable for BUFFER_FLUSH_SPEC { } # [doc = "`write(|w| ..)` method takes [`buffer_flush::W`](W) writer structure"]
impl crate :: Writable for BUFFER_FLUSH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BUFFER_FLUSH to value 0"]
impl crate :: Resettable for BUFFER_FLUSH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BUFFER_FILL (rw) register accessor: The current fill level of the audio buffer. The buffer is full when set to `0xFFF`\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`buffer_fill::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer_fill::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`buffer_fill`]
module"]
pub type BUFFER_FILL = crate :: Reg < buffer_fill :: BUFFER_FILL_SPEC > ; # [doc = "The current fill level of the audio buffer. The buffer is full when set to `0xFFF`"]
pub mod buffer_fill { # [doc = "Register `BUFFER_FILL` reader"]
pub type R = crate :: R < BUFFER_FILL_SPEC > ; # [doc = "Register `BUFFER_FILL` writer"]
pub type W = crate :: W < BUFFER_FILL_SPEC > ; # [doc = "Field `buffer_fill` reader - "]
pub type BUFFER_FILL_R = crate :: FieldReader < u16 > ; # [doc = "Field `buffer_fill` writer - "]
pub type BUFFER_FILL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn buffer_fill (& self) -> BUFFER_FILL_R { BUFFER_FILL_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn buffer_fill (& mut self) -> BUFFER_FILL_W < BUFFER_FILL_SPEC , 0 > { BUFFER_FILL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The current fill level of the audio buffer. The buffer is full when set to `0xFFF`\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`buffer_fill::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`buffer_fill::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BUFFER_FILL_SPEC ; impl crate :: RegisterSpec for BUFFER_FILL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`buffer_fill::R`](R) reader structure"]
impl crate :: Readable for BUFFER_FILL_SPEC { } # [doc = "`write(|w| ..)` method takes [`buffer_fill::W`](W) writer structure"]
impl crate :: Writable for BUFFER_FILL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BUFFER_FILL to value 0"]
impl crate :: Resettable for BUFFER_FILL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "APF_BRIDGE"]
pub struct APF_BRIDGE { _marker : PhantomData < * const () > } unsafe impl Send for APF_BRIDGE { } impl APF_BRIDGE { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_bridge :: RegisterBlock = 0xf000_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_bridge :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_BRIDGE { type Target = apf_bridge :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_BRIDGE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_BRIDGE") . finish () } } # [doc = "APF_BRIDGE"]
pub mod apf_bridge { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Writing 1 to this register will trigger a read request."]
pub request_read : REQUEST_READ , # [doc = "0x04 - The slot ID defined in `data.json` for the desired asset/slot."]
pub slot_id : SLOT_ID , # [doc = "0x08 - The offset from the start of the asset in the selected data slot to operate on."]
pub data_offset : DATA_OFFSET , # [doc = "0x0c - The length of data to transfer as part of this bridge operation. A length of `0xFFFFFFFF` will request the entire file (NOTE: As of Pocket firmware 1.1, this is bugged, and you just request the file size instead)."]
pub transfer_length : TRANSFER_LENGTH , # [doc = "0x10 - The address of RISC-V RAM to be manipulated in this operation. It is either the first write address for a read request, or the first read address for a write request."]
pub ram_data_address : RAM_DATA_ADDRESS , # [doc = "0x14 - The file size on disk of the current selected asset in slot `bridge_slot_id`."]
pub file_size : FILE_SIZE , # [doc = "0x18 - Indicates when the bridge is currently transferring a file. 1 when transferring, 0 otherwise. Clears its value on read."]
pub status : STATUS , # [doc = "0x1c - The current address the bridge is operating on. Can be used to show a progress bar/estimate time until completion."]
pub current_address : CURRENT_ADDRESS , } # [doc = "REQUEST_READ (rw) register accessor: Writing 1 to this register will trigger a read request.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`request_read::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`request_read::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`request_read`]
module"]
pub type REQUEST_READ = crate :: Reg < request_read :: REQUEST_READ_SPEC > ; # [doc = "Writing 1 to this register will trigger a read request."]
pub mod request_read { # [doc = "Register `REQUEST_READ` reader"]
pub type R = crate :: R < REQUEST_READ_SPEC > ; # [doc = "Register `REQUEST_READ` writer"]
pub type W = crate :: W < REQUEST_READ_SPEC > ; # [doc = "Field `request_read` reader - "]
pub type REQUEST_READ_R = crate :: BitReader ; # [doc = "Field `request_read` writer - "]
pub type REQUEST_READ_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn request_read (& self) -> REQUEST_READ_R { REQUEST_READ_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn request_read (& mut self) -> REQUEST_READ_W < REQUEST_READ_SPEC , 0 > { REQUEST_READ_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Writing 1 to this register will trigger a read request.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`request_read::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`request_read::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct REQUEST_READ_SPEC ; impl crate :: RegisterSpec for REQUEST_READ_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`request_read::R`](R) reader structure"]
impl crate :: Readable for REQUEST_READ_SPEC { } # [doc = "`write(|w| ..)` method takes [`request_read::W`](W) writer structure"]
impl crate :: Writable for REQUEST_READ_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REQUEST_READ to value 0"]
impl crate :: Resettable for REQUEST_READ_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SLOT_ID (rw) register accessor: The slot ID defined in `data.json` for the desired asset/slot.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`slot_id::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slot_id::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`slot_id`]
module"]
pub type SLOT_ID = crate :: Reg < slot_id :: SLOT_ID_SPEC > ; # [doc = "The slot ID defined in `data.json` for the desired asset/slot."]
pub mod slot_id { # [doc = "Register `SLOT_ID` reader"]
pub type R = crate :: R < SLOT_ID_SPEC > ; # [doc = "Register `SLOT_ID` writer"]
pub type W = crate :: W < SLOT_ID_SPEC > ; # [doc = "Field `slot_id` reader - "]
pub type SLOT_ID_R = crate :: FieldReader < u16 > ; # [doc = "Field `slot_id` writer - "]
pub type SLOT_ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn slot_id (& self) -> SLOT_ID_R { SLOT_ID_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn slot_id (& mut self) -> SLOT_ID_W < SLOT_ID_SPEC , 0 > { SLOT_ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The slot ID defined in `data.json` for the desired asset/slot.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`slot_id::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`slot_id::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SLOT_ID_SPEC ; impl crate :: RegisterSpec for SLOT_ID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`slot_id::R`](R) reader structure"]
impl crate :: Readable for SLOT_ID_SPEC { } # [doc = "`write(|w| ..)` method takes [`slot_id::W`](W) writer structure"]
impl crate :: Writable for SLOT_ID_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SLOT_ID to value 0"]
impl crate :: Resettable for SLOT_ID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA_OFFSET (rw) register accessor: The offset from the start of the asset in the selected data slot to operate on.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`data_offset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data_offset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`data_offset`]
module"]
pub type DATA_OFFSET = crate :: Reg < data_offset :: DATA_OFFSET_SPEC > ; # [doc = "The offset from the start of the asset in the selected data slot to operate on."]
pub mod data_offset { # [doc = "Register `DATA_OFFSET` reader"]
pub type R = crate :: R < DATA_OFFSET_SPEC > ; # [doc = "Register `DATA_OFFSET` writer"]
pub type W = crate :: W < DATA_OFFSET_SPEC > ; # [doc = "Field `data_offset` reader - "]
pub type DATA_OFFSET_R = crate :: FieldReader < u32 > ; # [doc = "Field `data_offset` writer - "]
pub type DATA_OFFSET_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn data_offset (& self) -> DATA_OFFSET_R { DATA_OFFSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn data_offset (& mut self) -> DATA_OFFSET_W < DATA_OFFSET_SPEC , 0 > { DATA_OFFSET_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The offset from the start of the asset in the selected data slot to operate on.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`data_offset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`data_offset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DATA_OFFSET_SPEC ; impl crate :: RegisterSpec for DATA_OFFSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`data_offset::R`](R) reader structure"]
impl crate :: Readable for DATA_OFFSET_SPEC { } # [doc = "`write(|w| ..)` method takes [`data_offset::W`](W) writer structure"]
impl crate :: Writable for DATA_OFFSET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA_OFFSET to value 0"]
impl crate :: Resettable for DATA_OFFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRANSFER_LENGTH (rw) register accessor: The length of data to transfer as part of this bridge operation. A length of `0xFFFFFFFF` will request the entire file (NOTE: As of Pocket firmware 1.1, this is bugged, and you just request the file size instead).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`transfer_length::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`transfer_length::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`transfer_length`]
module"]
pub type TRANSFER_LENGTH = crate :: Reg < transfer_length :: TRANSFER_LENGTH_SPEC > ; # [doc = "The length of data to transfer as part of this bridge operation. A length of `0xFFFFFFFF` will request the entire file (NOTE: As of Pocket firmware 1.1, this is bugged, and you just request the file size instead)."]
pub mod transfer_length { # [doc = "Register `TRANSFER_LENGTH` reader"]
pub type R = crate :: R < TRANSFER_LENGTH_SPEC > ; # [doc = "Register `TRANSFER_LENGTH` writer"]
pub type W = crate :: W < TRANSFER_LENGTH_SPEC > ; # [doc = "Field `transfer_length` reader - "]
pub type TRANSFER_LENGTH_R = crate :: FieldReader < u32 > ; # [doc = "Field `transfer_length` writer - "]
pub type TRANSFER_LENGTH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn transfer_length (& self) -> TRANSFER_LENGTH_R { TRANSFER_LENGTH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn transfer_length (& mut self) -> TRANSFER_LENGTH_W < TRANSFER_LENGTH_SPEC , 0 > { TRANSFER_LENGTH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The length of data to transfer as part of this bridge operation. A length of `0xFFFFFFFF` will request the entire file (NOTE: As of Pocket firmware 1.1, this is bugged, and you just request the file size instead).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`transfer_length::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`transfer_length::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TRANSFER_LENGTH_SPEC ; impl crate :: RegisterSpec for TRANSFER_LENGTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`transfer_length::R`](R) reader structure"]
impl crate :: Readable for TRANSFER_LENGTH_SPEC { } # [doc = "`write(|w| ..)` method takes [`transfer_length::W`](W) writer structure"]
impl crate :: Writable for TRANSFER_LENGTH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRANSFER_LENGTH to value 0"]
impl crate :: Resettable for TRANSFER_LENGTH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAM_DATA_ADDRESS (rw) register accessor: The address of RISC-V RAM to be manipulated in this operation. It is either the first write address for a read request, or the first read address for a write request.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ram_data_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ram_data_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ram_data_address`]
module"]
pub type RAM_DATA_ADDRESS = crate :: Reg < ram_data_address :: RAM_DATA_ADDRESS_SPEC > ; # [doc = "The address of RISC-V RAM to be manipulated in this operation. It is either the first write address for a read request, or the first read address for a write request."]
pub mod ram_data_address { # [doc = "Register `RAM_DATA_ADDRESS` reader"]
pub type R = crate :: R < RAM_DATA_ADDRESS_SPEC > ; # [doc = "Register `RAM_DATA_ADDRESS` writer"]
pub type W = crate :: W < RAM_DATA_ADDRESS_SPEC > ; # [doc = "Field `ram_data_address` reader - "]
pub type RAM_DATA_ADDRESS_R = crate :: FieldReader < u32 > ; # [doc = "Field `ram_data_address` writer - "]
pub type RAM_DATA_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn ram_data_address (& self) -> RAM_DATA_ADDRESS_R { RAM_DATA_ADDRESS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn ram_data_address (& mut self) -> RAM_DATA_ADDRESS_W < RAM_DATA_ADDRESS_SPEC , 0 > { RAM_DATA_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The address of RISC-V RAM to be manipulated in this operation. It is either the first write address for a read request, or the first read address for a write request.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ram_data_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ram_data_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RAM_DATA_ADDRESS_SPEC ; impl crate :: RegisterSpec for RAM_DATA_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ram_data_address::R`](R) reader structure"]
impl crate :: Readable for RAM_DATA_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ram_data_address::W`](W) writer structure"]
impl crate :: Writable for RAM_DATA_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAM_DATA_ADDRESS to value 0"]
impl crate :: Resettable for RAM_DATA_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FILE_SIZE (rw) register accessor: The file size on disk of the current selected asset in slot `bridge_slot_id`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`file_size::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`file_size::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`file_size`]
module"]
pub type FILE_SIZE = crate :: Reg < file_size :: FILE_SIZE_SPEC > ; # [doc = "The file size on disk of the current selected asset in slot `bridge_slot_id`."]
pub mod file_size { # [doc = "Register `FILE_SIZE` reader"]
pub type R = crate :: R < FILE_SIZE_SPEC > ; # [doc = "Register `FILE_SIZE` writer"]
pub type W = crate :: W < FILE_SIZE_SPEC > ; # [doc = "Field `file_size` reader - "]
pub type FILE_SIZE_R = crate :: FieldReader < u32 > ; # [doc = "Field `file_size` writer - "]
pub type FILE_SIZE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn file_size (& self) -> FILE_SIZE_R { FILE_SIZE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn file_size (& mut self) -> FILE_SIZE_W < FILE_SIZE_SPEC , 0 > { FILE_SIZE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The file size on disk of the current selected asset in slot `bridge_slot_id`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`file_size::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`file_size::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FILE_SIZE_SPEC ; impl crate :: RegisterSpec for FILE_SIZE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`file_size::R`](R) reader structure"]
impl crate :: Readable for FILE_SIZE_SPEC { } # [doc = "`write(|w| ..)` method takes [`file_size::W`](W) writer structure"]
impl crate :: Writable for FILE_SIZE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FILE_SIZE to value 0"]
impl crate :: Resettable for FILE_SIZE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: Indicates when the bridge is currently transferring a file. 1 when transferring, 0 otherwise. Clears its value on read.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`status`]
module"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Indicates when the bridge is currently transferring a file. 1 when transferring, 0 otherwise. Clears its value on read."]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < STATUS_SPEC > ; # [doc = "Register `STATUS` writer"]
pub type W = crate :: W < STATUS_SPEC > ; # [doc = "Field `status` reader - "]
pub type STATUS_R = crate :: BitReader ; # [doc = "Field `status` writer - "]
pub type STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn status (& self) -> STATUS_R { STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn status (& mut self) -> STATUS_W < STATUS_SPEC , 0 > { STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Indicates when the bridge is currently transferring a file. 1 when transferring, 0 otherwise. Clears its value on read.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`status::W`](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CURRENT_ADDRESS (rw) register accessor: The current address the bridge is operating on. Can be used to show a progress bar/estimate time until completion.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`current_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`current_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`current_address`]
module"]
pub type CURRENT_ADDRESS = crate :: Reg < current_address :: CURRENT_ADDRESS_SPEC > ; # [doc = "The current address the bridge is operating on. Can be used to show a progress bar/estimate time until completion."]
pub mod current_address { # [doc = "Register `CURRENT_ADDRESS` reader"]
pub type R = crate :: R < CURRENT_ADDRESS_SPEC > ; # [doc = "Register `CURRENT_ADDRESS` writer"]
pub type W = crate :: W < CURRENT_ADDRESS_SPEC > ; # [doc = "Field `current_address` reader - "]
pub type CURRENT_ADDRESS_R = crate :: FieldReader < u32 > ; # [doc = "Field `current_address` writer - "]
pub type CURRENT_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn current_address (& self) -> CURRENT_ADDRESS_R { CURRENT_ADDRESS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn current_address (& mut self) -> CURRENT_ADDRESS_W < CURRENT_ADDRESS_SPEC , 0 > { CURRENT_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The current address the bridge is operating on. Can be used to show a progress bar/estimate time until completion.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`current_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`current_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CURRENT_ADDRESS_SPEC ; impl crate :: RegisterSpec for CURRENT_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`current_address::R`](R) reader structure"]
impl crate :: Readable for CURRENT_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`current_address::W`](W) writer structure"]
impl crate :: Writable for CURRENT_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CURRENT_ADDRESS to value 0"]
impl crate :: Resettable for CURRENT_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "APF_ID"]
pub struct APF_ID { _marker : PhantomData < * const () > } unsafe impl Send for APF_ID { } impl APF_ID { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_id :: RegisterBlock = 0xf000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_id :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_ID { type Target = apf_id :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_ID { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_ID") . finish () } } # [doc = "APF_ID"]
pub mod apf_id { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Bits 32-63 of `APF_ID_ID`. The Cyclone V chip ID."]
pub id1 : ID1 , # [doc = "0x04 - Bits 0-31 of `APF_ID_ID`."]
pub id0 : ID0 , } # [doc = "ID1 (rw) register accessor: Bits 32-63 of `APF_ID_ID`. The Cyclone V chip ID.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`id1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`id1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`id1`]
module"]
pub type ID1 = crate :: Reg < id1 :: ID1_SPEC > ; # [doc = "Bits 32-63 of `APF_ID_ID`. The Cyclone V chip ID."]
pub mod id1 { # [doc = "Register `ID1` reader"]
pub type R = crate :: R < ID1_SPEC > ; # [doc = "Register `ID1` writer"]
pub type W = crate :: W < ID1_SPEC > ; # [doc = "Field `id` reader - "]
pub type ID_R = crate :: FieldReader < u32 > ; # [doc = "Field `id` writer - "]
pub type ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn id (& mut self) -> ID_W < ID1_SPEC , 0 > { ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 32-63 of `APF_ID_ID`. The Cyclone V chip ID.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`id1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`id1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ID1_SPEC ; impl crate :: RegisterSpec for ID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`id1::R`](R) reader structure"]
impl crate :: Readable for ID1_SPEC { } # [doc = "`write(|w| ..)` method takes [`id1::W`](W) writer structure"]
impl crate :: Writable for ID1_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ID1 to value 0"]
impl crate :: Resettable for ID1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ID0 (rw) register accessor: Bits 0-31 of `APF_ID_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`id0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`id0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`id0`]
module"]
pub type ID0 = crate :: Reg < id0 :: ID0_SPEC > ; # [doc = "Bits 0-31 of `APF_ID_ID`."]
pub mod id0 { # [doc = "Register `ID0` reader"]
pub type R = crate :: R < ID0_SPEC > ; # [doc = "Register `ID0` writer"]
pub type W = crate :: W < ID0_SPEC > ; # [doc = "Field `id` reader - "]
pub type ID_R = crate :: FieldReader < u32 > ; # [doc = "Field `id` writer - "]
pub type ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn id (& mut self) -> ID_W < ID0_SPEC , 0 > { ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 0-31 of `APF_ID_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`id0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`id0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ID0_SPEC ; impl crate :: RegisterSpec for ID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`id0::R`](R) reader structure"]
impl crate :: Readable for ID0_SPEC { } # [doc = "`write(|w| ..)` method takes [`id0::W`](W) writer structure"]
impl crate :: Writable for ID0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ID0 to value 0"]
impl crate :: Resettable for ID0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "APF_INPUT"]
pub struct APF_INPUT { _marker : PhantomData < * const () > } unsafe impl Send for APF_INPUT { } impl APF_INPUT { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_input :: RegisterBlock = 0xf000_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_input :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_INPUT { type Target = apf_input :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_INPUT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_INPUT") . finish () } } # [doc = "APF_INPUT"]
pub mod apf_input { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Controller 1 inputs. See docs."]
pub cont1_key : CONT1_KEY , # [doc = "0x04 - Controller 2 inputs. See docs."]
pub cont2_key : CONT2_KEY , # [doc = "0x08 - Controller 3 inputs. See docs."]
pub cont3_key : CONT3_KEY , # [doc = "0x0c - Controller 4 inputs. See docs."]
pub cont4_key : CONT4_KEY , # [doc = "0x10 - Controller 1 joystick values. See docs."]
pub cont1_joy : CONT1_JOY , # [doc = "0x14 - Controller 2 joystick values. See docs."]
pub cont2_joy : CONT2_JOY , # [doc = "0x18 - Controller 3 joystick values. See docs."]
pub cont3_joy : CONT3_JOY , # [doc = "0x1c - Controller 4 joystick values. See docs."]
pub cont4_joy : CONT4_JOY , # [doc = "0x20 - Controller 1 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub cont1_trig : CONT1_TRIG , # [doc = "0x24 - Controller 2 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub cont2_trig : CONT2_TRIG , # [doc = "0x28 - Controller 3 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub cont3_trig : CONT3_TRIG , # [doc = "0x2c - Controller 4 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub cont4_trig : CONT4_TRIG , } # [doc = "CONT1_KEY (rw) register accessor: Controller 1 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_key`]
module"]
pub type CONT1_KEY = crate :: Reg < cont1_key :: CONT1_KEY_SPEC > ; # [doc = "Controller 1 inputs. See docs."]
pub mod cont1_key { # [doc = "Register `CONT1_KEY` reader"]
pub type R = crate :: R < CONT1_KEY_SPEC > ; # [doc = "Register `CONT1_KEY` writer"]
pub type W = crate :: W < CONT1_KEY_SPEC > ; # [doc = "Field `cont1_key` reader - "]
pub type CONT1_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_key` writer - "]
pub type CONT1_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_key (& self) -> CONT1_KEY_R { CONT1_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_key (& mut self) -> CONT1_KEY_W < CONT1_KEY_SPEC , 0 > { CONT1_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 1 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_KEY_SPEC ; impl crate :: RegisterSpec for CONT1_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_key::R`](R) reader structure"]
impl crate :: Readable for CONT1_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_key::W`](W) writer structure"]
impl crate :: Writable for CONT1_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_KEY to value 0"]
impl crate :: Resettable for CONT1_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_KEY (rw) register accessor: Controller 2 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_key`]
module"]
pub type CONT2_KEY = crate :: Reg < cont2_key :: CONT2_KEY_SPEC > ; # [doc = "Controller 2 inputs. See docs."]
pub mod cont2_key { # [doc = "Register `CONT2_KEY` reader"]
pub type R = crate :: R < CONT2_KEY_SPEC > ; # [doc = "Register `CONT2_KEY` writer"]
pub type W = crate :: W < CONT2_KEY_SPEC > ; # [doc = "Field `cont2_key` reader - "]
pub type CONT2_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_key` writer - "]
pub type CONT2_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_key (& self) -> CONT2_KEY_R { CONT2_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_key (& mut self) -> CONT2_KEY_W < CONT2_KEY_SPEC , 0 > { CONT2_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 2 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_KEY_SPEC ; impl crate :: RegisterSpec for CONT2_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_key::R`](R) reader structure"]
impl crate :: Readable for CONT2_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_key::W`](W) writer structure"]
impl crate :: Writable for CONT2_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_KEY to value 0"]
impl crate :: Resettable for CONT2_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_KEY (rw) register accessor: Controller 3 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_key`]
module"]
pub type CONT3_KEY = crate :: Reg < cont3_key :: CONT3_KEY_SPEC > ; # [doc = "Controller 3 inputs. See docs."]
pub mod cont3_key { # [doc = "Register `CONT3_KEY` reader"]
pub type R = crate :: R < CONT3_KEY_SPEC > ; # [doc = "Register `CONT3_KEY` writer"]
pub type W = crate :: W < CONT3_KEY_SPEC > ; # [doc = "Field `cont3_key` reader - "]
pub type CONT3_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_key` writer - "]
pub type CONT3_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_key (& self) -> CONT3_KEY_R { CONT3_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_key (& mut self) -> CONT3_KEY_W < CONT3_KEY_SPEC , 0 > { CONT3_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 3 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_KEY_SPEC ; impl crate :: RegisterSpec for CONT3_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_key::R`](R) reader structure"]
impl crate :: Readable for CONT3_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_key::W`](W) writer structure"]
impl crate :: Writable for CONT3_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_KEY to value 0"]
impl crate :: Resettable for CONT3_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_KEY (rw) register accessor: Controller 4 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_key`]
module"]
pub type CONT4_KEY = crate :: Reg < cont4_key :: CONT4_KEY_SPEC > ; # [doc = "Controller 4 inputs. See docs."]
pub mod cont4_key { # [doc = "Register `CONT4_KEY` reader"]
pub type R = crate :: R < CONT4_KEY_SPEC > ; # [doc = "Register `CONT4_KEY` writer"]
pub type W = crate :: W < CONT4_KEY_SPEC > ; # [doc = "Field `cont4_key` reader - "]
pub type CONT4_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_key` writer - "]
pub type CONT4_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_key (& self) -> CONT4_KEY_R { CONT4_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_key (& mut self) -> CONT4_KEY_W < CONT4_KEY_SPEC , 0 > { CONT4_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 4 inputs. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_KEY_SPEC ; impl crate :: RegisterSpec for CONT4_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_key::R`](R) reader structure"]
impl crate :: Readable for CONT4_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_key::W`](W) writer structure"]
impl crate :: Writable for CONT4_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_KEY to value 0"]
impl crate :: Resettable for CONT4_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT1_JOY (rw) register accessor: Controller 1 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_joy`]
module"]
pub type CONT1_JOY = crate :: Reg < cont1_joy :: CONT1_JOY_SPEC > ; # [doc = "Controller 1 joystick values. See docs."]
pub mod cont1_joy { # [doc = "Register `CONT1_JOY` reader"]
pub type R = crate :: R < CONT1_JOY_SPEC > ; # [doc = "Register `CONT1_JOY` writer"]
pub type W = crate :: W < CONT1_JOY_SPEC > ; # [doc = "Field `cont1_joy` reader - "]
pub type CONT1_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_joy` writer - "]
pub type CONT1_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_joy (& self) -> CONT1_JOY_R { CONT1_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_joy (& mut self) -> CONT1_JOY_W < CONT1_JOY_SPEC , 0 > { CONT1_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 1 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_JOY_SPEC ; impl crate :: RegisterSpec for CONT1_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_joy::R`](R) reader structure"]
impl crate :: Readable for CONT1_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_joy::W`](W) writer structure"]
impl crate :: Writable for CONT1_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_JOY to value 0"]
impl crate :: Resettable for CONT1_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_JOY (rw) register accessor: Controller 2 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_joy`]
module"]
pub type CONT2_JOY = crate :: Reg < cont2_joy :: CONT2_JOY_SPEC > ; # [doc = "Controller 2 joystick values. See docs."]
pub mod cont2_joy { # [doc = "Register `CONT2_JOY` reader"]
pub type R = crate :: R < CONT2_JOY_SPEC > ; # [doc = "Register `CONT2_JOY` writer"]
pub type W = crate :: W < CONT2_JOY_SPEC > ; # [doc = "Field `cont2_joy` reader - "]
pub type CONT2_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_joy` writer - "]
pub type CONT2_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_joy (& self) -> CONT2_JOY_R { CONT2_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_joy (& mut self) -> CONT2_JOY_W < CONT2_JOY_SPEC , 0 > { CONT2_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 2 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_JOY_SPEC ; impl crate :: RegisterSpec for CONT2_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_joy::R`](R) reader structure"]
impl crate :: Readable for CONT2_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_joy::W`](W) writer structure"]
impl crate :: Writable for CONT2_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_JOY to value 0"]
impl crate :: Resettable for CONT2_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_JOY (rw) register accessor: Controller 3 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_joy`]
module"]
pub type CONT3_JOY = crate :: Reg < cont3_joy :: CONT3_JOY_SPEC > ; # [doc = "Controller 3 joystick values. See docs."]
pub mod cont3_joy { # [doc = "Register `CONT3_JOY` reader"]
pub type R = crate :: R < CONT3_JOY_SPEC > ; # [doc = "Register `CONT3_JOY` writer"]
pub type W = crate :: W < CONT3_JOY_SPEC > ; # [doc = "Field `cont3_joy` reader - "]
pub type CONT3_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_joy` writer - "]
pub type CONT3_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_joy (& self) -> CONT3_JOY_R { CONT3_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_joy (& mut self) -> CONT3_JOY_W < CONT3_JOY_SPEC , 0 > { CONT3_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 3 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_JOY_SPEC ; impl crate :: RegisterSpec for CONT3_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_joy::R`](R) reader structure"]
impl crate :: Readable for CONT3_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_joy::W`](W) writer structure"]
impl crate :: Writable for CONT3_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_JOY to value 0"]
impl crate :: Resettable for CONT3_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_JOY (rw) register accessor: Controller 4 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_joy`]
module"]
pub type CONT4_JOY = crate :: Reg < cont4_joy :: CONT4_JOY_SPEC > ; # [doc = "Controller 4 joystick values. See docs."]
pub mod cont4_joy { # [doc = "Register `CONT4_JOY` reader"]
pub type R = crate :: R < CONT4_JOY_SPEC > ; # [doc = "Register `CONT4_JOY` writer"]
pub type W = crate :: W < CONT4_JOY_SPEC > ; # [doc = "Field `cont4_joy` reader - "]
pub type CONT4_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_joy` writer - "]
pub type CONT4_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_joy (& self) -> CONT4_JOY_R { CONT4_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_joy (& mut self) -> CONT4_JOY_W < CONT4_JOY_SPEC , 0 > { CONT4_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 4 joystick values. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_JOY_SPEC ; impl crate :: RegisterSpec for CONT4_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_joy::R`](R) reader structure"]
impl crate :: Readable for CONT4_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_joy::W`](W) writer structure"]
impl crate :: Writable for CONT4_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_JOY to value 0"]
impl crate :: Resettable for CONT4_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT1_TRIG (rw) register accessor: Controller 1 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_trig`]
module"]
pub type CONT1_TRIG = crate :: Reg < cont1_trig :: CONT1_TRIG_SPEC > ; # [doc = "Controller 1 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub mod cont1_trig { # [doc = "Register `CONT1_TRIG` reader"]
pub type R = crate :: R < CONT1_TRIG_SPEC > ; # [doc = "Register `CONT1_TRIG` writer"]
pub type W = crate :: W < CONT1_TRIG_SPEC > ; # [doc = "Field `cont1_trig` reader - "]
pub type CONT1_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_trig` writer - "]
pub type CONT1_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_trig (& self) -> CONT1_TRIG_R { CONT1_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_trig (& mut self) -> CONT1_TRIG_W < CONT1_TRIG_SPEC , 0 > { CONT1_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 1 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_TRIG_SPEC ; impl crate :: RegisterSpec for CONT1_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_trig::R`](R) reader structure"]
impl crate :: Readable for CONT1_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_trig::W`](W) writer structure"]
impl crate :: Writable for CONT1_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_TRIG to value 0"]
impl crate :: Resettable for CONT1_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_TRIG (rw) register accessor: Controller 2 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_trig`]
module"]
pub type CONT2_TRIG = crate :: Reg < cont2_trig :: CONT2_TRIG_SPEC > ; # [doc = "Controller 2 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub mod cont2_trig { # [doc = "Register `CONT2_TRIG` reader"]
pub type R = crate :: R < CONT2_TRIG_SPEC > ; # [doc = "Register `CONT2_TRIG` writer"]
pub type W = crate :: W < CONT2_TRIG_SPEC > ; # [doc = "Field `cont2_trig` reader - "]
pub type CONT2_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_trig` writer - "]
pub type CONT2_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_trig (& self) -> CONT2_TRIG_R { CONT2_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_trig (& mut self) -> CONT2_TRIG_W < CONT2_TRIG_SPEC , 0 > { CONT2_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 2 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_TRIG_SPEC ; impl crate :: RegisterSpec for CONT2_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_trig::R`](R) reader structure"]
impl crate :: Readable for CONT2_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_trig::W`](W) writer structure"]
impl crate :: Writable for CONT2_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_TRIG to value 0"]
impl crate :: Resettable for CONT2_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_TRIG (rw) register accessor: Controller 3 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_trig`]
module"]
pub type CONT3_TRIG = crate :: Reg < cont3_trig :: CONT3_TRIG_SPEC > ; # [doc = "Controller 3 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub mod cont3_trig { # [doc = "Register `CONT3_TRIG` reader"]
pub type R = crate :: R < CONT3_TRIG_SPEC > ; # [doc = "Register `CONT3_TRIG` writer"]
pub type W = crate :: W < CONT3_TRIG_SPEC > ; # [doc = "Field `cont3_trig` reader - "]
pub type CONT3_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_trig` writer - "]
pub type CONT3_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_trig (& self) -> CONT3_TRIG_R { CONT3_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_trig (& mut self) -> CONT3_TRIG_W < CONT3_TRIG_SPEC , 0 > { CONT3_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 3 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_TRIG_SPEC ; impl crate :: RegisterSpec for CONT3_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_trig::R`](R) reader structure"]
impl crate :: Readable for CONT3_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_trig::W`](W) writer structure"]
impl crate :: Writable for CONT3_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_TRIG to value 0"]
impl crate :: Resettable for CONT3_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_TRIG (rw) register accessor: Controller 4 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_trig`]
module"]
pub type CONT4_TRIG = crate :: Reg < cont4_trig :: CONT4_TRIG_SPEC > ; # [doc = "Controller 4 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs."]
pub mod cont4_trig { # [doc = "Register `CONT4_TRIG` reader"]
pub type R = crate :: R < CONT4_TRIG_SPEC > ; # [doc = "Register `CONT4_TRIG` writer"]
pub type W = crate :: W < CONT4_TRIG_SPEC > ; # [doc = "Field `cont4_trig` reader - "]
pub type CONT4_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_trig` writer - "]
pub type CONT4_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_trig (& self) -> CONT4_TRIG_R { CONT4_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_trig (& mut self) -> CONT4_TRIG_W < CONT4_TRIG_SPEC , 0 > { CONT4_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Controller 4 trigger values. Values are binary on Pocket (`0 and 0xFFFF`), and analog on controllers with analog triggers. See docs.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_TRIG_SPEC ; impl crate :: RegisterSpec for CONT4_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_trig::R`](R) reader structure"]
impl crate :: Readable for CONT4_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_trig::W`](W) writer structure"]
impl crate :: Writable for CONT4_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_TRIG to value 0"]
impl crate :: Resettable for CONT4_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "APF_RTC"]
pub struct APF_RTC { _marker : PhantomData < * const () > } unsafe impl Send for APF_RTC { } impl APF_RTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_rtc :: RegisterBlock = 0xf000_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_rtc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_RTC { type Target = apf_rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_RTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_RTC") . finish () } } # [doc = "APF_RTC"]
pub mod apf_rtc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - The current Pocket set time, from Unix epoch, in seconds."]
pub unix_seconds : UNIX_SECONDS , # [doc = "0x04 - The launch Pocket set date, as BCD. NOT LIVE/INCREMENTING."]
pub date_bcd : DATE_BCD , # [doc = "0x08 - The launch Pocket set time, as BCD. NOT LIVE/INCREMENTING."]
pub time_bcd : TIME_BCD , } # [doc = "UNIX_SECONDS (rw) register accessor: The current Pocket set time, from Unix epoch, in seconds.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`unix_seconds::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`unix_seconds::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`unix_seconds`]
module"]
pub type UNIX_SECONDS = crate :: Reg < unix_seconds :: UNIX_SECONDS_SPEC > ; # [doc = "The current Pocket set time, from Unix epoch, in seconds."]
pub mod unix_seconds { # [doc = "Register `UNIX_SECONDS` reader"]
pub type R = crate :: R < UNIX_SECONDS_SPEC > ; # [doc = "Register `UNIX_SECONDS` writer"]
pub type W = crate :: W < UNIX_SECONDS_SPEC > ; # [doc = "Field `unix_seconds` reader - "]
pub type UNIX_SECONDS_R = crate :: FieldReader < u32 > ; # [doc = "Field `unix_seconds` writer - "]
pub type UNIX_SECONDS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn unix_seconds (& self) -> UNIX_SECONDS_R { UNIX_SECONDS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn unix_seconds (& mut self) -> UNIX_SECONDS_W < UNIX_SECONDS_SPEC , 0 > { UNIX_SECONDS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The current Pocket set time, from Unix epoch, in seconds.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`unix_seconds::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`unix_seconds::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UNIX_SECONDS_SPEC ; impl crate :: RegisterSpec for UNIX_SECONDS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`unix_seconds::R`](R) reader structure"]
impl crate :: Readable for UNIX_SECONDS_SPEC { } # [doc = "`write(|w| ..)` method takes [`unix_seconds::W`](W) writer structure"]
impl crate :: Writable for UNIX_SECONDS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UNIX_SECONDS to value 0"]
impl crate :: Resettable for UNIX_SECONDS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATE_BCD (rw) register accessor: The launch Pocket set date, as BCD. NOT LIVE/INCREMENTING.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`date_bcd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`date_bcd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`date_bcd`]
module"]
pub type DATE_BCD = crate :: Reg < date_bcd :: DATE_BCD_SPEC > ; # [doc = "The launch Pocket set date, as BCD. NOT LIVE/INCREMENTING."]
pub mod date_bcd { # [doc = "Register `DATE_BCD` reader"]
pub type R = crate :: R < DATE_BCD_SPEC > ; # [doc = "Register `DATE_BCD` writer"]
pub type W = crate :: W < DATE_BCD_SPEC > ; # [doc = "Field `date_bcd` reader - "]
pub type DATE_BCD_R = crate :: FieldReader < u32 > ; # [doc = "Field `date_bcd` writer - "]
pub type DATE_BCD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn date_bcd (& self) -> DATE_BCD_R { DATE_BCD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn date_bcd (& mut self) -> DATE_BCD_W < DATE_BCD_SPEC , 0 > { DATE_BCD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The launch Pocket set date, as BCD. NOT LIVE/INCREMENTING.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`date_bcd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`date_bcd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DATE_BCD_SPEC ; impl crate :: RegisterSpec for DATE_BCD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`date_bcd::R`](R) reader structure"]
impl crate :: Readable for DATE_BCD_SPEC { } # [doc = "`write(|w| ..)` method takes [`date_bcd::W`](W) writer structure"]
impl crate :: Writable for DATE_BCD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATE_BCD to value 0"]
impl crate :: Resettable for DATE_BCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIME_BCD (rw) register accessor: The launch Pocket set time, as BCD. NOT LIVE/INCREMENTING.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`time_bcd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`time_bcd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`time_bcd`]
module"]
pub type TIME_BCD = crate :: Reg < time_bcd :: TIME_BCD_SPEC > ; # [doc = "The launch Pocket set time, as BCD. NOT LIVE/INCREMENTING."]
pub mod time_bcd { # [doc = "Register `TIME_BCD` reader"]
pub type R = crate :: R < TIME_BCD_SPEC > ; # [doc = "Register `TIME_BCD` writer"]
pub type W = crate :: W < TIME_BCD_SPEC > ; # [doc = "Field `time_bcd` reader - "]
pub type TIME_BCD_R = crate :: FieldReader < u32 > ; # [doc = "Field `time_bcd` writer - "]
pub type TIME_BCD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn time_bcd (& self) -> TIME_BCD_R { TIME_BCD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn time_bcd (& mut self) -> TIME_BCD_W < TIME_BCD_SPEC , 0 > { TIME_BCD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "The launch Pocket set time, as BCD. NOT LIVE/INCREMENTING.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`time_bcd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`time_bcd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TIME_BCD_SPEC ; impl crate :: RegisterSpec for TIME_BCD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`time_bcd::R`](R) reader structure"]
impl crate :: Readable for TIME_BCD_SPEC { } # [doc = "`write(|w| ..)` method takes [`time_bcd::W`](W) writer structure"]
impl crate :: Writable for TIME_BCD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIME_BCD to value 0"]
impl crate :: Resettable for TIME_BCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "APF_VIDEO"]
pub struct APF_VIDEO { _marker : PhantomData < * const () > } unsafe impl Send for APF_VIDEO { } impl APF_VIDEO { # [doc = r"Pointer to the register block"]
pub const PTR : * const apf_video :: RegisterBlock = 0xf000_2800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const apf_video :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for APF_VIDEO { type Target = apf_video :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for APF_VIDEO { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("APF_VIDEO") . finish () } } # [doc = "APF_VIDEO"]
pub mod apf_video { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Indicates when vsync occurs. Becomes 1 at vsync, and is set to 0 whenever read. If you read 1, vsync has occured between your two reads."]
pub vsync_status : VSYNC_STATUS , # [doc = "0x04 - 1 when in vblank, 0 otherwise."]
pub vblank_status : VBLANK_STATUS , # [doc = "0x08 - Counts the number of frames displayed since startup. Comparing this value to a previous value can be used to track frame changes."]
pub frame_counter : FRAME_COUNTER , } # [doc = "VSYNC_STATUS (rw) register accessor: Indicates when vsync occurs. Becomes 1 at vsync, and is set to 0 whenever read. If you read 1, vsync has occured between your two reads.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_status`]
module"]
pub type VSYNC_STATUS = crate :: Reg < vsync_status :: VSYNC_STATUS_SPEC > ; # [doc = "Indicates when vsync occurs. Becomes 1 at vsync, and is set to 0 whenever read. If you read 1, vsync has occured between your two reads."]
pub mod vsync_status { # [doc = "Register `VSYNC_STATUS` reader"]
pub type R = crate :: R < VSYNC_STATUS_SPEC > ; # [doc = "Register `VSYNC_STATUS` writer"]
pub type W = crate :: W < VSYNC_STATUS_SPEC > ; # [doc = "Field `vsync_status` reader - "]
pub type VSYNC_STATUS_R = crate :: BitReader ; # [doc = "Field `vsync_status` writer - "]
pub type VSYNC_STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn vsync_status (& self) -> VSYNC_STATUS_R { VSYNC_STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn vsync_status (& mut self) -> VSYNC_STATUS_W < VSYNC_STATUS_SPEC , 0 > { VSYNC_STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Indicates when vsync occurs. Becomes 1 at vsync, and is set to 0 whenever read. If you read 1, vsync has occured between your two reads.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_STATUS_SPEC ; impl crate :: RegisterSpec for VSYNC_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_status::R`](R) reader structure"]
impl crate :: Readable for VSYNC_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_status::W`](W) writer structure"]
impl crate :: Writable for VSYNC_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_STATUS to value 0"]
impl crate :: Resettable for VSYNC_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VBLANK_STATUS (rw) register accessor: 1 when in vblank, 0 otherwise.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vblank_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vblank_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vblank_status`]
module"]
pub type VBLANK_STATUS = crate :: Reg < vblank_status :: VBLANK_STATUS_SPEC > ; # [doc = "1 when in vblank, 0 otherwise."]
pub mod vblank_status { # [doc = "Register `VBLANK_STATUS` reader"]
pub type R = crate :: R < VBLANK_STATUS_SPEC > ; # [doc = "Register `VBLANK_STATUS` writer"]
pub type W = crate :: W < VBLANK_STATUS_SPEC > ; # [doc = "Field `vblank_status` reader - "]
pub type VBLANK_STATUS_R = crate :: BitReader ; # [doc = "Field `vblank_status` writer - "]
pub type VBLANK_STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn vblank_status (& self) -> VBLANK_STATUS_R { VBLANK_STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn vblank_status (& mut self) -> VBLANK_STATUS_W < VBLANK_STATUS_SPEC , 0 > { VBLANK_STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "1 when in vblank, 0 otherwise.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vblank_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vblank_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VBLANK_STATUS_SPEC ; impl crate :: RegisterSpec for VBLANK_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vblank_status::R`](R) reader structure"]
impl crate :: Readable for VBLANK_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`vblank_status::W`](W) writer structure"]
impl crate :: Writable for VBLANK_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VBLANK_STATUS to value 0"]
impl crate :: Resettable for VBLANK_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FRAME_COUNTER (rw) register accessor: Counts the number of frames displayed since startup. Comparing this value to a previous value can be used to track frame changes.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`frame_counter::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`frame_counter::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`frame_counter`]
module"]
pub type FRAME_COUNTER = crate :: Reg < frame_counter :: FRAME_COUNTER_SPEC > ; # [doc = "Counts the number of frames displayed since startup. Comparing this value to a previous value can be used to track frame changes."]
pub mod frame_counter { # [doc = "Register `FRAME_COUNTER` reader"]
pub type R = crate :: R < FRAME_COUNTER_SPEC > ; # [doc = "Register `FRAME_COUNTER` writer"]
pub type W = crate :: W < FRAME_COUNTER_SPEC > ; # [doc = "Field `frame_counter` reader - "]
pub type FRAME_COUNTER_R = crate :: FieldReader < u32 > ; # [doc = "Field `frame_counter` writer - "]
pub type FRAME_COUNTER_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn frame_counter (& self) -> FRAME_COUNTER_R { FRAME_COUNTER_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn frame_counter (& mut self) -> FRAME_COUNTER_W < FRAME_COUNTER_SPEC , 0 > { FRAME_COUNTER_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Counts the number of frames displayed since startup. Comparing this value to a previous value can be used to track frame changes.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`frame_counter::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`frame_counter::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FRAME_COUNTER_SPEC ; impl crate :: RegisterSpec for FRAME_COUNTER_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`frame_counter::R`](R) reader structure"]
impl crate :: Readable for FRAME_COUNTER_SPEC { } # [doc = "`write(|w| ..)` method takes [`frame_counter::W`](W) writer structure"]
impl crate :: Writable for FRAME_COUNTER_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FRAME_COUNTER to value 0"]
impl crate :: Resettable for FRAME_COUNTER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CTRL"]
pub struct CTRL { _marker : PhantomData < * const () > } unsafe impl Send for CTRL { } impl CTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const ctrl :: RegisterBlock = 0xf000_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ctrl :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for CTRL { type Target = ctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CTRL") . finish () } } # [doc = "CTRL"]
pub mod ctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub reset : RESET , # [doc = "0x04 - Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
pub scratch : SCRATCH , # [doc = "0x08 - Total number of Wishbone bus errors (timeouts) since start."]
pub bus_errors : BUS_ERRORS , } # [doc = "RESET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`reset`]
module"]
pub type RESET = crate :: Reg < reset :: RESET_SPEC > ; # [doc = ""]
pub mod reset { # [doc = "Register `RESET` reader"]
pub type R = crate :: R < RESET_SPEC > ; # [doc = "Register `RESET` writer"]
pub type W = crate :: W < RESET_SPEC > ; # [doc = "Field `soc_rst` reader - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SOC_RST_R = crate :: BitReader ; # [doc = "Field `soc_rst` writer - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SOC_RST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cpu_rst` reader - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CPU_RST_R = crate :: BitReader ; # [doc = "Field `cpu_rst` writer - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CPU_RST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
pub fn soc_rst (& self) -> SOC_RST_R { SOC_RST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
pub fn cpu_rst (& self) -> CPU_RST_R { CPU_RST_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
# [must_use]
pub fn soc_rst (& mut self) -> SOC_RST_W < RESET_SPEC , 0 > { SOC_RST_W :: new (self) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
# [must_use]
pub fn cpu_rst (& mut self) -> CPU_RST_W < RESET_SPEC , 1 > { CPU_RST_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RESET_SPEC ; impl crate :: RegisterSpec for RESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`reset::R`](R) reader structure"]
impl crate :: Readable for RESET_SPEC { } # [doc = "`write(|w| ..)` method takes [`reset::W`](W) writer structure"]
impl crate :: Writable for RESET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RESET to value 0"]
impl crate :: Resettable for RESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCRATCH (rw) register accessor: Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`scratch`]
module"]
pub type SCRATCH = crate :: Reg < scratch :: SCRATCH_SPEC > ; # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
pub mod scratch { # [doc = "Register `SCRATCH` reader"]
pub type R = crate :: R < SCRATCH_SPEC > ; # [doc = "Register `SCRATCH` writer"]
pub type W = crate :: W < SCRATCH_SPEC > ; # [doc = "Field `scratch` reader - "]
pub type SCRATCH_R = crate :: FieldReader < u32 > ; # [doc = "Field `scratch` writer - "]
pub type SCRATCH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn scratch (& self) -> SCRATCH_R { SCRATCH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn scratch (& mut self) -> SCRATCH_W < SCRATCH_SPEC , 0 > { SCRATCH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SCRATCH_SPEC ; impl crate :: RegisterSpec for SCRATCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`scratch::R`](R) reader structure"]
impl crate :: Readable for SCRATCH_SPEC { } # [doc = "`write(|w| ..)` method takes [`scratch::W`](W) writer structure"]
impl crate :: Writable for SCRATCH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCRATCH to value 0x1234_5678"]
impl crate :: Resettable for SCRATCH_SPEC { const RESET_VALUE : Self :: Ux = 0x1234_5678 ; } } # [doc = "BUS_ERRORS (rw) register accessor: Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bus_errors`]
module"]
pub type BUS_ERRORS = crate :: Reg < bus_errors :: BUS_ERRORS_SPEC > ; # [doc = "Total number of Wishbone bus errors (timeouts) since start."]
pub mod bus_errors { # [doc = "Register `BUS_ERRORS` reader"]
pub type R = crate :: R < BUS_ERRORS_SPEC > ; # [doc = "Register `BUS_ERRORS` writer"]
pub type W = crate :: W < BUS_ERRORS_SPEC > ; # [doc = "Field `bus_errors` reader - "]
pub type BUS_ERRORS_R = crate :: FieldReader < u32 > ; # [doc = "Field `bus_errors` writer - "]
pub type BUS_ERRORS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bus_errors (& self) -> BUS_ERRORS_R { BUS_ERRORS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bus_errors (& mut self) -> BUS_ERRORS_W < BUS_ERRORS_SPEC , 0 > { BUS_ERRORS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BUS_ERRORS_SPEC ; impl crate :: RegisterSpec for BUS_ERRORS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bus_errors::R`](R) reader structure"]
impl crate :: Readable for BUS_ERRORS_SPEC { } # [doc = "`write(|w| ..)` method takes [`bus_errors::W`](W) writer structure"]
impl crate :: Writable for BUS_ERRORS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BUS_ERRORS to value 0"]
impl crate :: Resettable for BUS_ERRORS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "IDENTIFIER_MEM"]
pub struct IDENTIFIER_MEM { _marker : PhantomData < * const () > } unsafe impl Send for IDENTIFIER_MEM { } impl IDENTIFIER_MEM { # [doc = r"Pointer to the register block"]
pub const PTR : * const identifier_mem :: RegisterBlock = 0xf000_3800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const identifier_mem :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for IDENTIFIER_MEM { type Target = identifier_mem :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IDENTIFIER_MEM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IDENTIFIER_MEM") . finish () } } # [doc = "IDENTIFIER_MEM"]
pub mod identifier_mem { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - 8 x 47-bit memory"]
pub identifier_mem : IDENTIFIER_MEM , } # [doc = "IDENTIFIER_MEM (rw) register accessor: 8 x 47-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`identifier_mem`]
module"]
pub type IDENTIFIER_MEM = crate :: Reg < identifier_mem :: IDENTIFIER_MEM_SPEC > ; # [doc = "8 x 47-bit memory"]
pub mod identifier_mem { # [doc = "Register `IDENTIFIER_MEM` reader"]
pub type R = crate :: R < IDENTIFIER_MEM_SPEC > ; # [doc = "Register `IDENTIFIER_MEM` writer"]
pub type W = crate :: W < IDENTIFIER_MEM_SPEC > ; # [doc = "Field `identifier_mem` reader - "]
pub type IDENTIFIER_MEM_R = crate :: FieldReader ; # [doc = "Field `identifier_mem` writer - "]
pub type IDENTIFIER_MEM_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 8 , O > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn identifier_mem (& self) -> IDENTIFIER_MEM_R { IDENTIFIER_MEM_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn identifier_mem (& mut self) -> IDENTIFIER_MEM_W < IDENTIFIER_MEM_SPEC , 0 > { IDENTIFIER_MEM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "8 x 47-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IDENTIFIER_MEM_SPEC ; impl crate :: RegisterSpec for IDENTIFIER_MEM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`identifier_mem::R`](R) reader structure"]
impl crate :: Readable for IDENTIFIER_MEM_SPEC { } # [doc = "`write(|w| ..)` method takes [`identifier_mem::W`](W) writer structure"]
impl crate :: Writable for IDENTIFIER_MEM_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IDENTIFIER_MEM to value 0"]
impl crate :: Resettable for IDENTIFIER_MEM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "SDRAM"]
pub struct SDRAM { _marker : PhantomData < * const () > } unsafe impl Send for SDRAM { } impl SDRAM { # [doc = r"Pointer to the register block"]
pub const PTR : * const sdram :: RegisterBlock = 0xf000_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sdram :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SDRAM { type Target = sdram :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SDRAM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SDRAM") . finish () } } # [doc = "SDRAM"]
pub mod sdram { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control DFI signals common to all phases"]
pub dfii_control : DFII_CONTROL , # [doc = "0x04 - Control DFI signals on a single phase"]
pub dfii_pi0_command : DFII_PI0_COMMAND , # [doc = "0x08 - "]
pub dfii_pi0_command_issue : DFII_PI0_COMMAND_ISSUE , # [doc = "0x0c - DFI address bus"]
pub dfii_pi0_address : DFII_PI0_ADDRESS , # [doc = "0x10 - DFI bank address bus"]
pub dfii_pi0_baddress : DFII_PI0_BADDRESS , # [doc = "0x14 - DFI write data bus"]
pub dfii_pi0_wrdata : DFII_PI0_WRDATA , # [doc = "0x18 - DFI read data bus"]
pub dfii_pi0_rddata : DFII_PI0_RDDATA , # [doc = "0x1c - Control DFI signals on a single phase"]
pub dfii_pi1_command : DFII_PI1_COMMAND , # [doc = "0x20 - "]
pub dfii_pi1_command_issue : DFII_PI1_COMMAND_ISSUE , # [doc = "0x24 - DFI address bus"]
pub dfii_pi1_address : DFII_PI1_ADDRESS , # [doc = "0x28 - DFI bank address bus"]
pub dfii_pi1_baddress : DFII_PI1_BADDRESS , # [doc = "0x2c - DFI write data bus"]
pub dfii_pi1_wrdata : DFII_PI1_WRDATA , # [doc = "0x30 - DFI read data bus"]
pub dfii_pi1_rddata : DFII_PI1_RDDATA , } # [doc = "DFII_CONTROL (rw) register accessor: Control DFI signals common to all phases\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_control::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_control::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_control`]
module"]
pub type DFII_CONTROL = crate :: Reg < dfii_control :: DFII_CONTROL_SPEC > ; # [doc = "Control DFI signals common to all phases"]
pub mod dfii_control { # [doc = "Register `DFII_CONTROL` reader"]
pub type R = crate :: R < DFII_CONTROL_SPEC > ; # [doc = "Register `DFII_CONTROL` writer"]
pub type W = crate :: W < DFII_CONTROL_SPEC > ; # [doc = "Field `sel` reader - None"]
pub type SEL_R = crate :: BitReader ; # [doc = "Field `sel` writer - None"]
pub type SEL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cke` reader - DFI clock enable bus"]
pub type CKE_R = crate :: BitReader ; # [doc = "Field `cke` writer - DFI clock enable bus"]
pub type CKE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `odt` reader - DFI on-die termination bus"]
pub type ODT_R = crate :: BitReader ; # [doc = "Field `odt` writer - DFI on-die termination bus"]
pub type ODT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `reset_n` reader - DFI clock reset bus"]
pub type RESET_N_R = crate :: BitReader ; # [doc = "Field `reset_n` writer - DFI clock reset bus"]
pub type RESET_N_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn sel (& self) -> SEL_R { SEL_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
pub fn cke (& self) -> CKE_R { CKE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
pub fn odt (& self) -> ODT_R { ODT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
pub fn reset_n (& self) -> RESET_N_R { RESET_N_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn sel (& mut self) -> SEL_W < DFII_CONTROL_SPEC , 0 > { SEL_W :: new (self) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
# [must_use]
pub fn cke (& mut self) -> CKE_W < DFII_CONTROL_SPEC , 1 > { CKE_W :: new (self) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
# [must_use]
pub fn odt (& mut self) -> ODT_W < DFII_CONTROL_SPEC , 2 > { ODT_W :: new (self) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
# [must_use]
pub fn reset_n (& mut self) -> RESET_N_W < DFII_CONTROL_SPEC , 3 > { RESET_N_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals common to all phases\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_control::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_control::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_CONTROL_SPEC ; impl crate :: RegisterSpec for DFII_CONTROL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_control::R`](R) reader structure"]
impl crate :: Readable for DFII_CONTROL_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_control::W`](W) writer structure"]
impl crate :: Writable for DFII_CONTROL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_CONTROL to value 0x01"]
impl crate :: Resettable for DFII_CONTROL_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "DFII_PI0_COMMAND (rw) register accessor: Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_command`]
module"]
pub type DFII_PI0_COMMAND = crate :: Reg < dfii_pi0_command :: DFII_PI0_COMMAND_SPEC > ; # [doc = "Control DFI signals on a single phase"]
pub mod dfii_pi0_command { # [doc = "Register `DFII_PI0_COMMAND` reader"]
pub type R = crate :: R < DFII_PI0_COMMAND_SPEC > ; # [doc = "Register `DFII_PI0_COMMAND` writer"]
pub type W = crate :: W < DFII_PI0_COMMAND_SPEC > ; # [doc = "Field `cs` reader - DFI chip select bus"]
pub type CS_R = crate :: BitReader ; # [doc = "Field `cs` writer - DFI chip select bus"]
pub type CS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `we` reader - DFI write enable bus"]
pub type WE_R = crate :: BitReader ; # [doc = "Field `we` writer - DFI write enable bus"]
pub type WE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cas` reader - DFI column address strobe bus"]
pub type CAS_R = crate :: BitReader ; # [doc = "Field `cas` writer - DFI column address strobe bus"]
pub type CAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `ras` reader - DFI row address strobe bus"]
pub type RAS_R = crate :: BitReader ; # [doc = "Field `ras` writer - DFI row address strobe bus"]
pub type RAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `wren` reader - DFI write data enable bus"]
pub type WREN_R = crate :: BitReader ; # [doc = "Field `wren` writer - DFI write data enable bus"]
pub type WREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rden` reader - DFI read data enable bus"]
pub type RDEN_R = crate :: BitReader ; # [doc = "Field `rden` writer - DFI read data enable bus"]
pub type RDEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_top` reader - DFI chip select bus for top half only"]
pub type CS_TOP_R = crate :: BitReader ; # [doc = "Field `cs_top` writer - DFI chip select bus for top half only"]
pub type CS_TOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_bottom` reader - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_R = crate :: BitReader ; # [doc = "Field `cs_bottom` writer - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
pub fn cs (& self) -> CS_R { CS_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
pub fn we (& self) -> WE_R { WE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
pub fn cas (& self) -> CAS_R { CAS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
pub fn ras (& self) -> RAS_R { RAS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
pub fn wren (& self) -> WREN_R { WREN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
pub fn rden (& self) -> RDEN_R { RDEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
pub fn cs_top (& self) -> CS_TOP_R { CS_TOP_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
pub fn cs_bottom (& self) -> CS_BOTTOM_R { CS_BOTTOM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
# [must_use]
pub fn cs (& mut self) -> CS_W < DFII_PI0_COMMAND_SPEC , 0 > { CS_W :: new (self) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
# [must_use]
pub fn we (& mut self) -> WE_W < DFII_PI0_COMMAND_SPEC , 1 > { WE_W :: new (self) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
# [must_use]
pub fn cas (& mut self) -> CAS_W < DFII_PI0_COMMAND_SPEC , 2 > { CAS_W :: new (self) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
# [must_use]
pub fn ras (& mut self) -> RAS_W < DFII_PI0_COMMAND_SPEC , 3 > { RAS_W :: new (self) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
# [must_use]
pub fn wren (& mut self) -> WREN_W < DFII_PI0_COMMAND_SPEC , 4 > { WREN_W :: new (self) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
# [must_use]
pub fn rden (& mut self) -> RDEN_W < DFII_PI0_COMMAND_SPEC , 5 > { RDEN_W :: new (self) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
# [must_use]
pub fn cs_top (& mut self) -> CS_TOP_W < DFII_PI0_COMMAND_SPEC , 6 > { CS_TOP_W :: new (self) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
# [must_use]
pub fn cs_bottom (& mut self) -> CS_BOTTOM_W < DFII_PI0_COMMAND_SPEC , 7 > { CS_BOTTOM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_COMMAND_SPEC ; impl crate :: RegisterSpec for DFII_PI0_COMMAND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_COMMAND_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_COMMAND_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND to value 0"]
impl crate :: Resettable for DFII_PI0_COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_COMMAND_ISSUE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command_issue::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_command_issue`]
module"]
pub type DFII_PI0_COMMAND_ISSUE = crate :: Reg < dfii_pi0_command_issue :: DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = ""]
pub mod dfii_pi0_command_issue { # [doc = "Register `DFII_PI0_COMMAND_ISSUE` reader"]
pub type R = crate :: R < DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = "Register `DFII_PI0_COMMAND_ISSUE` writer"]
pub type W = crate :: W < DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = "Field `dfii_pi0_command_issue` reader - "]
pub type DFII_PI0_COMMAND_ISSUE_R = crate :: BitReader ; # [doc = "Field `dfii_pi0_command_issue` writer - "]
pub type DFII_PI0_COMMAND_ISSUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi0_command_issue (& self) -> DFII_PI0_COMMAND_ISSUE_R { DFII_PI0_COMMAND_ISSUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_command_issue (& mut self) -> DFII_PI0_COMMAND_ISSUE_W < DFII_PI0_COMMAND_ISSUE_SPEC , 0 > { DFII_PI0_COMMAND_ISSUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command_issue::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_COMMAND_ISSUE_SPEC ; impl crate :: RegisterSpec for DFII_PI0_COMMAND_ISSUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command_issue::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_COMMAND_ISSUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command_issue::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_COMMAND_ISSUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND_ISSUE to value 0"]
impl crate :: Resettable for DFII_PI0_COMMAND_ISSUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_ADDRESS (rw) register accessor: DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_address`]
module"]
pub type DFII_PI0_ADDRESS = crate :: Reg < dfii_pi0_address :: DFII_PI0_ADDRESS_SPEC > ; # [doc = "DFI address bus"]
pub mod dfii_pi0_address { # [doc = "Register `DFII_PI0_ADDRESS` reader"]
pub type R = crate :: R < DFII_PI0_ADDRESS_SPEC > ; # [doc = "Register `DFII_PI0_ADDRESS` writer"]
pub type W = crate :: W < DFII_PI0_ADDRESS_SPEC > ; # [doc = "Field `dfii_pi0_address` reader - "]
pub type DFII_PI0_ADDRESS_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_address` writer - "]
pub type DFII_PI0_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 13 , O , u16 > ; impl R { # [doc = "Bits 0:12"]
# [inline (always)]
pub fn dfii_pi0_address (& self) -> DFII_PI0_ADDRESS_R { DFII_PI0_ADDRESS_R :: new ((self . bits & 0x1fff) as u16) } } impl W { # [doc = "Bits 0:12"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_address (& mut self) -> DFII_PI0_ADDRESS_W < DFII_PI0_ADDRESS_SPEC , 0 > { DFII_PI0_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_ADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI0_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_address::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_address::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_ADDRESS to value 0"]
impl crate :: Resettable for DFII_PI0_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_BADDRESS (rw) register accessor: DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_baddress::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_baddress`]
module"]
pub type DFII_PI0_BADDRESS = crate :: Reg < dfii_pi0_baddress :: DFII_PI0_BADDRESS_SPEC > ; # [doc = "DFI bank address bus"]
pub mod dfii_pi0_baddress { # [doc = "Register `DFII_PI0_BADDRESS` reader"]
pub type R = crate :: R < DFII_PI0_BADDRESS_SPEC > ; # [doc = "Register `DFII_PI0_BADDRESS` writer"]
pub type W = crate :: W < DFII_PI0_BADDRESS_SPEC > ; # [doc = "Field `dfii_pi0_baddress` reader - "]
pub type DFII_PI0_BADDRESS_R = crate :: FieldReader ; # [doc = "Field `dfii_pi0_baddress` writer - "]
pub type DFII_PI0_BADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O > ; impl R { # [doc = "Bits 0:1"]
# [inline (always)]
pub fn dfii_pi0_baddress (& self) -> DFII_PI0_BADDRESS_R { DFII_PI0_BADDRESS_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_baddress (& mut self) -> DFII_PI0_BADDRESS_W < DFII_PI0_BADDRESS_SPEC , 0 > { DFII_PI0_BADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_baddress::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_BADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI0_BADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_baddress::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_BADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_baddress::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_BADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_BADDRESS to value 0"]
impl crate :: Resettable for DFII_PI0_BADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_WRDATA (rw) register accessor: DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_wrdata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_wrdata`]
module"]
pub type DFII_PI0_WRDATA = crate :: Reg < dfii_pi0_wrdata :: DFII_PI0_WRDATA_SPEC > ; # [doc = "DFI write data bus"]
pub mod dfii_pi0_wrdata { # [doc = "Register `DFII_PI0_WRDATA` reader"]
pub type R = crate :: R < DFII_PI0_WRDATA_SPEC > ; # [doc = "Register `DFII_PI0_WRDATA` writer"]
pub type W = crate :: W < DFII_PI0_WRDATA_SPEC > ; # [doc = "Field `dfii_pi0_wrdata` reader - "]
pub type DFII_PI0_WRDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_wrdata` writer - "]
pub type DFII_PI0_WRDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi0_wrdata (& self) -> DFII_PI0_WRDATA_R { DFII_PI0_WRDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_wrdata (& mut self) -> DFII_PI0_WRDATA_W < DFII_PI0_WRDATA_SPEC , 0 > { DFII_PI0_WRDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_wrdata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_WRDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI0_WRDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_wrdata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_WRDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_wrdata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_WRDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_WRDATA to value 0"]
impl crate :: Resettable for DFII_PI0_WRDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_RDDATA (rw) register accessor: DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_rddata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_rddata`]
module"]
pub type DFII_PI0_RDDATA = crate :: Reg < dfii_pi0_rddata :: DFII_PI0_RDDATA_SPEC > ; # [doc = "DFI read data bus"]
pub mod dfii_pi0_rddata { # [doc = "Register `DFII_PI0_RDDATA` reader"]
pub type R = crate :: R < DFII_PI0_RDDATA_SPEC > ; # [doc = "Register `DFII_PI0_RDDATA` writer"]
pub type W = crate :: W < DFII_PI0_RDDATA_SPEC > ; # [doc = "Field `dfii_pi0_rddata` reader - "]
pub type DFII_PI0_RDDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_rddata` writer - "]
pub type DFII_PI0_RDDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi0_rddata (& self) -> DFII_PI0_RDDATA_R { DFII_PI0_RDDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_rddata (& mut self) -> DFII_PI0_RDDATA_W < DFII_PI0_RDDATA_SPEC , 0 > { DFII_PI0_RDDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_rddata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_RDDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI0_RDDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_rddata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_RDDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_rddata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_RDDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_RDDATA to value 0"]
impl crate :: Resettable for DFII_PI0_RDDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_COMMAND (rw) register accessor: Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_command`]
module"]
pub type DFII_PI1_COMMAND = crate :: Reg < dfii_pi1_command :: DFII_PI1_COMMAND_SPEC > ; # [doc = "Control DFI signals on a single phase"]
pub mod dfii_pi1_command { # [doc = "Register `DFII_PI1_COMMAND` reader"]
pub type R = crate :: R < DFII_PI1_COMMAND_SPEC > ; # [doc = "Register `DFII_PI1_COMMAND` writer"]
pub type W = crate :: W < DFII_PI1_COMMAND_SPEC > ; # [doc = "Field `cs` reader - DFI chip select bus"]
pub type CS_R = crate :: BitReader ; # [doc = "Field `cs` writer - DFI chip select bus"]
pub type CS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `we` reader - DFI write enable bus"]
pub type WE_R = crate :: BitReader ; # [doc = "Field `we` writer - DFI write enable bus"]
pub type WE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cas` reader - DFI column address strobe bus"]
pub type CAS_R = crate :: BitReader ; # [doc = "Field `cas` writer - DFI column address strobe bus"]
pub type CAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `ras` reader - DFI row address strobe bus"]
pub type RAS_R = crate :: BitReader ; # [doc = "Field `ras` writer - DFI row address strobe bus"]
pub type RAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `wren` reader - DFI write data enable bus"]
pub type WREN_R = crate :: BitReader ; # [doc = "Field `wren` writer - DFI write data enable bus"]
pub type WREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rden` reader - DFI read data enable bus"]
pub type RDEN_R = crate :: BitReader ; # [doc = "Field `rden` writer - DFI read data enable bus"]
pub type RDEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_top` reader - DFI chip select bus for top half only"]
pub type CS_TOP_R = crate :: BitReader ; # [doc = "Field `cs_top` writer - DFI chip select bus for top half only"]
pub type CS_TOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_bottom` reader - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_R = crate :: BitReader ; # [doc = "Field `cs_bottom` writer - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
pub fn cs (& self) -> CS_R { CS_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
pub fn we (& self) -> WE_R { WE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
pub fn cas (& self) -> CAS_R { CAS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
pub fn ras (& self) -> RAS_R { RAS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
pub fn wren (& self) -> WREN_R { WREN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
pub fn rden (& self) -> RDEN_R { RDEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
pub fn cs_top (& self) -> CS_TOP_R { CS_TOP_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
pub fn cs_bottom (& self) -> CS_BOTTOM_R { CS_BOTTOM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
# [must_use]
pub fn cs (& mut self) -> CS_W < DFII_PI1_COMMAND_SPEC , 0 > { CS_W :: new (self) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
# [must_use]
pub fn we (& mut self) -> WE_W < DFII_PI1_COMMAND_SPEC , 1 > { WE_W :: new (self) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
# [must_use]
pub fn cas (& mut self) -> CAS_W < DFII_PI1_COMMAND_SPEC , 2 > { CAS_W :: new (self) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
# [must_use]
pub fn ras (& mut self) -> RAS_W < DFII_PI1_COMMAND_SPEC , 3 > { RAS_W :: new (self) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
# [must_use]
pub fn wren (& mut self) -> WREN_W < DFII_PI1_COMMAND_SPEC , 4 > { WREN_W :: new (self) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
# [must_use]
pub fn rden (& mut self) -> RDEN_W < DFII_PI1_COMMAND_SPEC , 5 > { RDEN_W :: new (self) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
# [must_use]
pub fn cs_top (& mut self) -> CS_TOP_W < DFII_PI1_COMMAND_SPEC , 6 > { CS_TOP_W :: new (self) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
# [must_use]
pub fn cs_bottom (& mut self) -> CS_BOTTOM_W < DFII_PI1_COMMAND_SPEC , 7 > { CS_BOTTOM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_COMMAND_SPEC ; impl crate :: RegisterSpec for DFII_PI1_COMMAND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_command::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_COMMAND_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_command::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_COMMAND_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_COMMAND to value 0"]
impl crate :: Resettable for DFII_PI1_COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_COMMAND_ISSUE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command_issue::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command_issue::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_command_issue`]
module"]
pub type DFII_PI1_COMMAND_ISSUE = crate :: Reg < dfii_pi1_command_issue :: DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = ""]
pub mod dfii_pi1_command_issue { # [doc = "Register `DFII_PI1_COMMAND_ISSUE` reader"]
pub type R = crate :: R < DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = "Register `DFII_PI1_COMMAND_ISSUE` writer"]
pub type W = crate :: W < DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = "Field `dfii_pi1_command_issue` reader - "]
pub type DFII_PI1_COMMAND_ISSUE_R = crate :: BitReader ; # [doc = "Field `dfii_pi1_command_issue` writer - "]
pub type DFII_PI1_COMMAND_ISSUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi1_command_issue (& self) -> DFII_PI1_COMMAND_ISSUE_R { DFII_PI1_COMMAND_ISSUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_command_issue (& mut self) -> DFII_PI1_COMMAND_ISSUE_W < DFII_PI1_COMMAND_ISSUE_SPEC , 0 > { DFII_PI1_COMMAND_ISSUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command_issue::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command_issue::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_COMMAND_ISSUE_SPEC ; impl crate :: RegisterSpec for DFII_PI1_COMMAND_ISSUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_command_issue::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_COMMAND_ISSUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_command_issue::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_COMMAND_ISSUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_COMMAND_ISSUE to value 0"]
impl crate :: Resettable for DFII_PI1_COMMAND_ISSUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_ADDRESS (rw) register accessor: DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_address`]
module"]
pub type DFII_PI1_ADDRESS = crate :: Reg < dfii_pi1_address :: DFII_PI1_ADDRESS_SPEC > ; # [doc = "DFI address bus"]
pub mod dfii_pi1_address { # [doc = "Register `DFII_PI1_ADDRESS` reader"]
pub type R = crate :: R < DFII_PI1_ADDRESS_SPEC > ; # [doc = "Register `DFII_PI1_ADDRESS` writer"]
pub type W = crate :: W < DFII_PI1_ADDRESS_SPEC > ; # [doc = "Field `dfii_pi1_address` reader - "]
pub type DFII_PI1_ADDRESS_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_address` writer - "]
pub type DFII_PI1_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 13 , O , u16 > ; impl R { # [doc = "Bits 0:12"]
# [inline (always)]
pub fn dfii_pi1_address (& self) -> DFII_PI1_ADDRESS_R { DFII_PI1_ADDRESS_R :: new ((self . bits & 0x1fff) as u16) } } impl W { # [doc = "Bits 0:12"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_address (& mut self) -> DFII_PI1_ADDRESS_W < DFII_PI1_ADDRESS_SPEC , 0 > { DFII_PI1_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_ADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI1_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_address::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_address::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_ADDRESS to value 0"]
impl crate :: Resettable for DFII_PI1_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_BADDRESS (rw) register accessor: DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_baddress::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_baddress::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_baddress`]
module"]
pub type DFII_PI1_BADDRESS = crate :: Reg < dfii_pi1_baddress :: DFII_PI1_BADDRESS_SPEC > ; # [doc = "DFI bank address bus"]
pub mod dfii_pi1_baddress { # [doc = "Register `DFII_PI1_BADDRESS` reader"]
pub type R = crate :: R < DFII_PI1_BADDRESS_SPEC > ; # [doc = "Register `DFII_PI1_BADDRESS` writer"]
pub type W = crate :: W < DFII_PI1_BADDRESS_SPEC > ; # [doc = "Field `dfii_pi1_baddress` reader - "]
pub type DFII_PI1_BADDRESS_R = crate :: FieldReader ; # [doc = "Field `dfii_pi1_baddress` writer - "]
pub type DFII_PI1_BADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O > ; impl R { # [doc = "Bits 0:1"]
# [inline (always)]
pub fn dfii_pi1_baddress (& self) -> DFII_PI1_BADDRESS_R { DFII_PI1_BADDRESS_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_baddress (& mut self) -> DFII_PI1_BADDRESS_W < DFII_PI1_BADDRESS_SPEC , 0 > { DFII_PI1_BADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_baddress::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_baddress::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_BADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI1_BADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_baddress::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_BADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_baddress::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_BADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_BADDRESS to value 0"]
impl crate :: Resettable for DFII_PI1_BADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_WRDATA (rw) register accessor: DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_wrdata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_wrdata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_wrdata`]
module"]
pub type DFII_PI1_WRDATA = crate :: Reg < dfii_pi1_wrdata :: DFII_PI1_WRDATA_SPEC > ; # [doc = "DFI write data bus"]
pub mod dfii_pi1_wrdata { # [doc = "Register `DFII_PI1_WRDATA` reader"]
pub type R = crate :: R < DFII_PI1_WRDATA_SPEC > ; # [doc = "Register `DFII_PI1_WRDATA` writer"]
pub type W = crate :: W < DFII_PI1_WRDATA_SPEC > ; # [doc = "Field `dfii_pi1_wrdata` reader - "]
pub type DFII_PI1_WRDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_wrdata` writer - "]
pub type DFII_PI1_WRDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi1_wrdata (& self) -> DFII_PI1_WRDATA_R { DFII_PI1_WRDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_wrdata (& mut self) -> DFII_PI1_WRDATA_W < DFII_PI1_WRDATA_SPEC , 0 > { DFII_PI1_WRDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_wrdata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_wrdata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_WRDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI1_WRDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_wrdata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_WRDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_wrdata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_WRDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_WRDATA to value 0"]
impl crate :: Resettable for DFII_PI1_WRDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_RDDATA (rw) register accessor: DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_rddata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_rddata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_rddata`]
module"]
pub type DFII_PI1_RDDATA = crate :: Reg < dfii_pi1_rddata :: DFII_PI1_RDDATA_SPEC > ; # [doc = "DFI read data bus"]
pub mod dfii_pi1_rddata { # [doc = "Register `DFII_PI1_RDDATA` reader"]
pub type R = crate :: R < DFII_PI1_RDDATA_SPEC > ; # [doc = "Register `DFII_PI1_RDDATA` writer"]
pub type W = crate :: W < DFII_PI1_RDDATA_SPEC > ; # [doc = "Field `dfii_pi1_rddata` reader - "]
pub type DFII_PI1_RDDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_rddata` writer - "]
pub type DFII_PI1_RDDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi1_rddata (& self) -> DFII_PI1_RDDATA_R { DFII_PI1_RDDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_rddata (& mut self) -> DFII_PI1_RDDATA_W < DFII_PI1_RDDATA_SPEC , 0 > { DFII_PI1_RDDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_rddata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_rddata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_RDDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI1_RDDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_rddata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_RDDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_rddata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_RDDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_RDDATA to value 0"]
impl crate :: Resettable for DFII_PI1_RDDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "TIMER0"]
pub struct TIMER0 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER0 { } impl TIMER0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer0 :: RegisterBlock = 0xf000_4800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMER0 { type Target = timer0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER0") . finish () } } # [doc = "TIMER0"]
pub mod timer0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
pub load : LOAD , # [doc = "0x04 - Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
pub reload : RELOAD , # [doc = "0x08 - Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
pub en : EN , # [doc = "0x0c - Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
pub update_value : UPDATE_VALUE , # [doc = "0x10 - Latched countdown value. This value is updated by writing to ``update_value``."]
pub value : VALUE , # [doc = "0x14 - This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
pub ev_status : EV_STATUS , # [doc = "0x18 - When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub ev_pending : EV_PENDING , # [doc = "0x1c - This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
pub ev_enable : EV_ENABLE , # [doc = "0x20 - Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register."]
pub uptime_latch : UPTIME_LATCH , # [doc = "0x24 - Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles)."]
pub uptime_cycles1 : UPTIME_CYCLES1 , # [doc = "0x28 - Bits 0-31 of `TIMER0_UPTIME_CYCLES`."]
pub uptime_cycles0 : UPTIME_CYCLES0 , } # [doc = "LOAD (rw) register accessor: Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`load`]
module"]
pub type LOAD = crate :: Reg < load :: LOAD_SPEC > ; # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
pub mod load { # [doc = "Register `LOAD` reader"]
pub type R = crate :: R < LOAD_SPEC > ; # [doc = "Register `LOAD` writer"]
pub type W = crate :: W < LOAD_SPEC > ; # [doc = "Field `load` reader - "]
pub type LOAD_R = crate :: FieldReader < u32 > ; # [doc = "Field `load` writer - "]
pub type LOAD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn load (& self) -> LOAD_R { LOAD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn load (& mut self) -> LOAD_W < LOAD_SPEC , 0 > { LOAD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LOAD_SPEC ; impl crate :: RegisterSpec for LOAD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`load::R`](R) reader structure"]
impl crate :: Readable for LOAD_SPEC { } # [doc = "`write(|w| ..)` method takes [`load::W`](W) writer structure"]
impl crate :: Writable for LOAD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOAD to value 0"]
impl crate :: Resettable for LOAD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RELOAD (rw) register accessor: Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`reload`]
module"]
pub type RELOAD = crate :: Reg < reload :: RELOAD_SPEC > ; # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
pub mod reload { # [doc = "Register `RELOAD` reader"]
pub type R = crate :: R < RELOAD_SPEC > ; # [doc = "Register `RELOAD` writer"]
pub type W = crate :: W < RELOAD_SPEC > ; # [doc = "Field `reload` reader - "]
pub type RELOAD_R = crate :: FieldReader < u32 > ; # [doc = "Field `reload` writer - "]
pub type RELOAD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn reload (& self) -> RELOAD_R { RELOAD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn reload (& mut self) -> RELOAD_W < RELOAD_SPEC , 0 > { RELOAD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RELOAD_SPEC ; impl crate :: RegisterSpec for RELOAD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`reload::R`](R) reader structure"]
impl crate :: Readable for RELOAD_SPEC { } # [doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
impl crate :: Writable for RELOAD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RELOAD to value 0"]
impl crate :: Resettable for RELOAD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EN (rw) register accessor: Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`en`]
module"]
pub type EN = crate :: Reg < en :: EN_SPEC > ; # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
pub mod en { # [doc = "Register `EN` reader"]
pub type R = crate :: R < EN_SPEC > ; # [doc = "Register `EN` writer"]
pub type W = crate :: W < EN_SPEC > ; # [doc = "Field `en` reader - "]
pub type EN_R = crate :: BitReader ; # [doc = "Field `en` writer - "]
pub type EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn en (& self) -> EN_R { EN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn en (& mut self) -> EN_W < EN_SPEC , 0 > { EN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EN_SPEC ; impl crate :: RegisterSpec for EN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`en::R`](R) reader structure"]
impl crate :: Readable for EN_SPEC { } # [doc = "`write(|w| ..)` method takes [`en::W`](W) writer structure"]
impl crate :: Writable for EN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EN to value 0"]
impl crate :: Resettable for EN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPDATE_VALUE (rw) register accessor: Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`update_value`]
module"]
pub type UPDATE_VALUE = crate :: Reg < update_value :: UPDATE_VALUE_SPEC > ; # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
pub mod update_value { # [doc = "Register `UPDATE_VALUE` reader"]
pub type R = crate :: R < UPDATE_VALUE_SPEC > ; # [doc = "Register `UPDATE_VALUE` writer"]
pub type W = crate :: W < UPDATE_VALUE_SPEC > ; # [doc = "Field `update_value` reader - "]
pub type UPDATE_VALUE_R = crate :: BitReader ; # [doc = "Field `update_value` writer - "]
pub type UPDATE_VALUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn update_value (& self) -> UPDATE_VALUE_R { UPDATE_VALUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn update_value (& mut self) -> UPDATE_VALUE_W < UPDATE_VALUE_SPEC , 0 > { UPDATE_VALUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPDATE_VALUE_SPEC ; impl crate :: RegisterSpec for UPDATE_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`update_value::R`](R) reader structure"]
impl crate :: Readable for UPDATE_VALUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`update_value::W`](W) writer structure"]
impl crate :: Writable for UPDATE_VALUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPDATE_VALUE to value 0"]
impl crate :: Resettable for UPDATE_VALUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VALUE (rw) register accessor: Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`value`]
module"]
pub type VALUE = crate :: Reg < value :: VALUE_SPEC > ; # [doc = "Latched countdown value. This value is updated by writing to ``update_value``."]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < VALUE_SPEC > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < VALUE_SPEC > ; # [doc = "Field `value` reader - "]
pub type VALUE_R = crate :: FieldReader < u32 > ; # [doc = "Field `value` writer - "]
pub type VALUE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < VALUE_SPEC , 0 > { VALUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VALUE_SPEC ; impl crate :: RegisterSpec for VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for VALUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for VALUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for VALUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_status`]
module"]
pub type EV_STATUS = crate :: Reg < ev_status :: EV_STATUS_SPEC > ; # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EV_STATUS_SPEC > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EV_STATUS_SPEC > ; # [doc = "Field `zero` reader - Level of the ``zero`` event"]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - Level of the ``zero`` event"]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_STATUS_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_STATUS_SPEC ; impl crate :: RegisterSpec for EV_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EV_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EV_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EV_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_pending`]
module"]
pub type EV_PENDING = crate :: Reg < ev_pending :: EV_PENDING_SPEC > ; # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EV_PENDING_SPEC > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EV_PENDING_SPEC > ; # [doc = "Field `zero` reader - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_PENDING_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_PENDING_SPEC ; impl crate :: RegisterSpec for EV_PENDING_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EV_PENDING_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EV_PENDING_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EV_PENDING_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_enable`]
module"]
pub type EV_ENABLE = crate :: Reg < ev_enable :: EV_ENABLE_SPEC > ; # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EV_ENABLE_SPEC > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EV_ENABLE_SPEC > ; # [doc = "Field `zero` reader - Write a ``1`` to enable the ``zero`` Event"]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - Write a ``1`` to enable the ``zero`` Event"]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_ENABLE_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_ENABLE_SPEC ; impl crate :: RegisterSpec for EV_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EV_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EV_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EV_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_LATCH (rw) register accessor: Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_latch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_latch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_latch`]
module"]
pub type UPTIME_LATCH = crate :: Reg < uptime_latch :: UPTIME_LATCH_SPEC > ; # [doc = "Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register."]
pub mod uptime_latch { # [doc = "Register `UPTIME_LATCH` reader"]
pub type R = crate :: R < UPTIME_LATCH_SPEC > ; # [doc = "Register `UPTIME_LATCH` writer"]
pub type W = crate :: W < UPTIME_LATCH_SPEC > ; # [doc = "Field `uptime_latch` reader - "]
pub type UPTIME_LATCH_R = crate :: BitReader ; # [doc = "Field `uptime_latch` writer - "]
pub type UPTIME_LATCH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn uptime_latch (& self) -> UPTIME_LATCH_R { UPTIME_LATCH_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn uptime_latch (& mut self) -> UPTIME_LATCH_W < UPTIME_LATCH_SPEC , 0 > { UPTIME_LATCH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_latch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_latch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_LATCH_SPEC ; impl crate :: RegisterSpec for UPTIME_LATCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_latch::R`](R) reader structure"]
impl crate :: Readable for UPTIME_LATCH_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_latch::W`](W) writer structure"]
impl crate :: Writable for UPTIME_LATCH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_LATCH to value 0"]
impl crate :: Resettable for UPTIME_LATCH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_CYCLES1 (rw) register accessor: Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_cycles1`]
module"]
pub type UPTIME_CYCLES1 = crate :: Reg < uptime_cycles1 :: UPTIME_CYCLES1_SPEC > ; # [doc = "Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles)."]
pub mod uptime_cycles1 { # [doc = "Register `UPTIME_CYCLES1` reader"]
pub type R = crate :: R < UPTIME_CYCLES1_SPEC > ; # [doc = "Register `UPTIME_CYCLES1` writer"]
pub type W = crate :: W < UPTIME_CYCLES1_SPEC > ; # [doc = "Field `uptime_cycles` reader - "]
pub type UPTIME_CYCLES_R = crate :: FieldReader < u32 > ; # [doc = "Field `uptime_cycles` writer - "]
pub type UPTIME_CYCLES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn uptime_cycles (& self) -> UPTIME_CYCLES_R { UPTIME_CYCLES_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn uptime_cycles (& mut self) -> UPTIME_CYCLES_W < UPTIME_CYCLES1_SPEC , 0 > { UPTIME_CYCLES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_CYCLES1_SPEC ; impl crate :: RegisterSpec for UPTIME_CYCLES1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_cycles1::R`](R) reader structure"]
impl crate :: Readable for UPTIME_CYCLES1_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_cycles1::W`](W) writer structure"]
impl crate :: Writable for UPTIME_CYCLES1_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_CYCLES1 to value 0"]
impl crate :: Resettable for UPTIME_CYCLES1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_CYCLES0 (rw) register accessor: Bits 0-31 of `TIMER0_UPTIME_CYCLES`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_cycles0`]
module"]
pub type UPTIME_CYCLES0 = crate :: Reg < uptime_cycles0 :: UPTIME_CYCLES0_SPEC > ; # [doc = "Bits 0-31 of `TIMER0_UPTIME_CYCLES`."]
pub mod uptime_cycles0 { # [doc = "Register `UPTIME_CYCLES0` reader"]
pub type R = crate :: R < UPTIME_CYCLES0_SPEC > ; # [doc = "Register `UPTIME_CYCLES0` writer"]
pub type W = crate :: W < UPTIME_CYCLES0_SPEC > ; # [doc = "Field `uptime_cycles` reader - "]
pub type UPTIME_CYCLES_R = crate :: FieldReader < u32 > ; # [doc = "Field `uptime_cycles` writer - "]
pub type UPTIME_CYCLES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn uptime_cycles (& self) -> UPTIME_CYCLES_R { UPTIME_CYCLES_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn uptime_cycles (& mut self) -> UPTIME_CYCLES_W < UPTIME_CYCLES0_SPEC , 0 > { UPTIME_CYCLES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 0-31 of `TIMER0_UPTIME_CYCLES`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_CYCLES0_SPEC ; impl crate :: RegisterSpec for UPTIME_CYCLES0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_cycles0::R`](R) reader structure"]
impl crate :: Readable for UPTIME_CYCLES0_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_cycles0::W`](W) writer structure"]
impl crate :: Writable for UPTIME_CYCLES0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_CYCLES0 to value 0"]
impl crate :: Resettable for UPTIME_CYCLES0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "UART"]
pub struct UART { _marker : PhantomData < * const () > } unsafe impl Send for UART { } impl UART { # [doc = r"Pointer to the register block"]
pub const PTR : * const uart :: RegisterBlock = 0xf000_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uart :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for UART { type Target = uart :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UART { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART") . finish () } } # [doc = "UART"]
pub mod uart { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub rxtx : RXTX , # [doc = "0x04 - TX FIFO Full."]
pub txfull : TXFULL , # [doc = "0x08 - RX FIFO Empty."]
pub rxempty : RXEMPTY , # [doc = "0x0c - This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
pub ev_status : EV_STATUS , # [doc = "0x10 - When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub ev_pending : EV_PENDING , # [doc = "0x14 - This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
pub ev_enable : EV_ENABLE , # [doc = "0x18 - TX FIFO Empty."]
pub txempty : TXEMPTY , # [doc = "0x1c - RX FIFO Full."]
pub rxfull : RXFULL , } # [doc = "RXTX (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxtx`]
module"]
pub type RXTX = crate :: Reg < rxtx :: RXTX_SPEC > ; # [doc = ""]
pub mod rxtx { # [doc = "Register `RXTX` reader"]
pub type R = crate :: R < RXTX_SPEC > ; # [doc = "Register `RXTX` writer"]
pub type W = crate :: W < RXTX_SPEC > ; # [doc = "Field `rxtx` reader - "]
pub type RXTX_R = crate :: FieldReader ; # [doc = "Field `rxtx` writer - "]
pub type RXTX_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 8 , O > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn rxtx (& self) -> RXTX_R { RXTX_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn rxtx (& mut self) -> RXTX_W < RXTX_SPEC , 0 > { RXTX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXTX_SPEC ; impl crate :: RegisterSpec for RXTX_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxtx::R`](R) reader structure"]
impl crate :: Readable for RXTX_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxtx::W`](W) writer structure"]
impl crate :: Writable for RXTX_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXTX to value 0"]
impl crate :: Resettable for RXTX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXFULL (rw) register accessor: TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`txfull`]
module"]
pub type TXFULL = crate :: Reg < txfull :: TXFULL_SPEC > ; # [doc = "TX FIFO Full."]
pub mod txfull { # [doc = "Register `TXFULL` reader"]
pub type R = crate :: R < TXFULL_SPEC > ; # [doc = "Register `TXFULL` writer"]
pub type W = crate :: W < TXFULL_SPEC > ; # [doc = "Field `txfull` reader - "]
pub type TXFULL_R = crate :: BitReader ; # [doc = "Field `txfull` writer - "]
pub type TXFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txfull (& self) -> TXFULL_R { TXFULL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txfull (& mut self) -> TXFULL_W < TXFULL_SPEC , 0 > { TXFULL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXFULL_SPEC ; impl crate :: RegisterSpec for TXFULL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`txfull::R`](R) reader structure"]
impl crate :: Readable for TXFULL_SPEC { } # [doc = "`write(|w| ..)` method takes [`txfull::W`](W) writer structure"]
impl crate :: Writable for TXFULL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXFULL to value 0"]
impl crate :: Resettable for TXFULL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXEMPTY (rw) register accessor: RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxempty`]
module"]
pub type RXEMPTY = crate :: Reg < rxempty :: RXEMPTY_SPEC > ; # [doc = "RX FIFO Empty."]
pub mod rxempty { # [doc = "Register `RXEMPTY` reader"]
pub type R = crate :: R < RXEMPTY_SPEC > ; # [doc = "Register `RXEMPTY` writer"]
pub type W = crate :: W < RXEMPTY_SPEC > ; # [doc = "Field `rxempty` reader - "]
pub type RXEMPTY_R = crate :: BitReader ; # [doc = "Field `rxempty` writer - "]
pub type RXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxempty (& self) -> RXEMPTY_R { RXEMPTY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxempty (& mut self) -> RXEMPTY_W < RXEMPTY_SPEC , 0 > { RXEMPTY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXEMPTY_SPEC ; impl crate :: RegisterSpec for RXEMPTY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxempty::R`](R) reader structure"]
impl crate :: Readable for RXEMPTY_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxempty::W`](W) writer structure"]
impl crate :: Writable for RXEMPTY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXEMPTY to value 0"]
impl crate :: Resettable for RXEMPTY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_status`]
module"]
pub type EV_STATUS = crate :: Reg < ev_status :: EV_STATUS_SPEC > ; # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EV_STATUS_SPEC > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EV_STATUS_SPEC > ; # [doc = "Field `tx` reader - Level of the ``tx`` event"]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - Level of the ``tx`` event"]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - Level of the ``rx`` event"]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - Level of the ``rx`` event"]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_STATUS_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_STATUS_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_STATUS_SPEC ; impl crate :: RegisterSpec for EV_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EV_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EV_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EV_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_pending`]
module"]
pub type EV_PENDING = crate :: Reg < ev_pending :: EV_PENDING_SPEC > ; # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EV_PENDING_SPEC > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EV_PENDING_SPEC > ; # [doc = "Field `tx` reader - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_PENDING_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_PENDING_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_PENDING_SPEC ; impl crate :: RegisterSpec for EV_PENDING_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EV_PENDING_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EV_PENDING_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EV_PENDING_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_enable`]
module"]
pub type EV_ENABLE = crate :: Reg < ev_enable :: EV_ENABLE_SPEC > ; # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EV_ENABLE_SPEC > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EV_ENABLE_SPEC > ; # [doc = "Field `tx` reader - Write a ``1`` to enable the ``tx`` Event"]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - Write a ``1`` to enable the ``tx`` Event"]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - Write a ``1`` to enable the ``rx`` Event"]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - Write a ``1`` to enable the ``rx`` Event"]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_ENABLE_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_ENABLE_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_ENABLE_SPEC ; impl crate :: RegisterSpec for EV_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EV_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EV_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EV_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXEMPTY (rw) register accessor: TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`txempty`]
module"]
pub type TXEMPTY = crate :: Reg < txempty :: TXEMPTY_SPEC > ; # [doc = "TX FIFO Empty."]
pub mod txempty { # [doc = "Register `TXEMPTY` reader"]
pub type R = crate :: R < TXEMPTY_SPEC > ; # [doc = "Register `TXEMPTY` writer"]
pub type W = crate :: W < TXEMPTY_SPEC > ; # [doc = "Field `txempty` reader - "]
pub type TXEMPTY_R = crate :: BitReader ; # [doc = "Field `txempty` writer - "]
pub type TXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txempty (& mut self) -> TXEMPTY_W < TXEMPTY_SPEC , 0 > { TXEMPTY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXEMPTY_SPEC ; impl crate :: RegisterSpec for TXEMPTY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`txempty::R`](R) reader structure"]
impl crate :: Readable for TXEMPTY_SPEC { } # [doc = "`write(|w| ..)` method takes [`txempty::W`](W) writer structure"]
impl crate :: Writable for TXEMPTY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXEMPTY to value 0"]
impl crate :: Resettable for TXEMPTY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXFULL (rw) register accessor: RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxfull`]
module"]
pub type RXFULL = crate :: Reg < rxfull :: RXFULL_SPEC > ; # [doc = "RX FIFO Full."]
pub mod rxfull { # [doc = "Register `RXFULL` reader"]
pub type R = crate :: R < RXFULL_SPEC > ; # [doc = "Register `RXFULL` writer"]
pub type W = crate :: W < RXFULL_SPEC > ; # [doc = "Field `rxfull` reader - "]
pub type RXFULL_R = crate :: BitReader ; # [doc = "Field `rxfull` writer - "]
pub type RXFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxfull (& mut self) -> RXFULL_W < RXFULL_SPEC , 0 > { RXFULL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXFULL_SPEC ; impl crate :: RegisterSpec for RXFULL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxfull::R`](R) reader structure"]
impl crate :: Readable for RXFULL_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxfull::W`](W) writer structure"]
impl crate :: Writable for RXFULL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXFULL to value 0"]
impl crate :: Resettable for RXFULL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "VIDEO_FRAMEBUFFER"]
pub struct VIDEO_FRAMEBUFFER { _marker : PhantomData < * const () > } unsafe impl Send for VIDEO_FRAMEBUFFER { } impl VIDEO_FRAMEBUFFER { # [doc = r"Pointer to the register block"]
pub const PTR : * const video_framebuffer :: RegisterBlock = 0xf000_5800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const video_framebuffer :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for VIDEO_FRAMEBUFFER { type Target = video_framebuffer :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VIDEO_FRAMEBUFFER { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VIDEO_FRAMEBUFFER") . finish () } } # [doc = "VIDEO_FRAMEBUFFER"]
pub mod video_framebuffer { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub dma_base : DMA_BASE , # [doc = "0x04 - "]
pub dma_length : DMA_LENGTH , # [doc = "0x08 - "]
pub dma_enable : DMA_ENABLE , # [doc = "0x0c - "]
pub dma_done : DMA_DONE , # [doc = "0x10 - "]
pub dma_loop : DMA_LOOP , # [doc = "0x14 - "]
pub dma_offset : DMA_OFFSET , } # [doc = "DMA_BASE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_base::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_base::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_base`]
module"]
pub type DMA_BASE = crate :: Reg < dma_base :: DMA_BASE_SPEC > ; # [doc = ""]
pub mod dma_base { # [doc = "Register `DMA_BASE` reader"]
pub type R = crate :: R < DMA_BASE_SPEC > ; # [doc = "Register `DMA_BASE` writer"]
pub type W = crate :: W < DMA_BASE_SPEC > ; # [doc = "Field `dma_base` reader - "]
pub type DMA_BASE_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_base` writer - "]
pub type DMA_BASE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_base (& self) -> DMA_BASE_R { DMA_BASE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_base (& mut self) -> DMA_BASE_W < DMA_BASE_SPEC , 0 > { DMA_BASE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_base::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_base::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_BASE_SPEC ; impl crate :: RegisterSpec for DMA_BASE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_base::R`](R) reader structure"]
impl crate :: Readable for DMA_BASE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_base::W`](W) writer structure"]
impl crate :: Writable for DMA_BASE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_BASE to value 0x40c0_0000"]
impl crate :: Resettable for DMA_BASE_SPEC { const RESET_VALUE : Self :: Ux = 0x40c0_0000 ; } } # [doc = "DMA_LENGTH (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_length::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_length::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_length`]
module"]
pub type DMA_LENGTH = crate :: Reg < dma_length :: DMA_LENGTH_SPEC > ; # [doc = ""]
pub mod dma_length { # [doc = "Register `DMA_LENGTH` reader"]
pub type R = crate :: R < DMA_LENGTH_SPEC > ; # [doc = "Register `DMA_LENGTH` writer"]
pub type W = crate :: W < DMA_LENGTH_SPEC > ; # [doc = "Field `dma_length` reader - "]
pub type DMA_LENGTH_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_length` writer - "]
pub type DMA_LENGTH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_length (& self) -> DMA_LENGTH_R { DMA_LENGTH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_length (& mut self) -> DMA_LENGTH_W < DMA_LENGTH_SPEC , 0 > { DMA_LENGTH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_length::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_length::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_LENGTH_SPEC ; impl crate :: RegisterSpec for DMA_LENGTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_length::R`](R) reader structure"]
impl crate :: Readable for DMA_LENGTH_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_length::W`](W) writer structure"]
impl crate :: Writable for DMA_LENGTH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_LENGTH to value 0x0001_f2c0"]
impl crate :: Resettable for DMA_LENGTH_SPEC { const RESET_VALUE : Self :: Ux = 0x0001_f2c0 ; } } # [doc = "DMA_ENABLE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_enable`]
module"]
pub type DMA_ENABLE = crate :: Reg < dma_enable :: DMA_ENABLE_SPEC > ; # [doc = ""]
pub mod dma_enable { # [doc = "Register `DMA_ENABLE` reader"]
pub type R = crate :: R < DMA_ENABLE_SPEC > ; # [doc = "Register `DMA_ENABLE` writer"]
pub type W = crate :: W < DMA_ENABLE_SPEC > ; # [doc = "Field `dma_enable` reader - "]
pub type DMA_ENABLE_R = crate :: BitReader ; # [doc = "Field `dma_enable` writer - "]
pub type DMA_ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_enable (& self) -> DMA_ENABLE_R { DMA_ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_enable (& mut self) -> DMA_ENABLE_W < DMA_ENABLE_SPEC , 0 > { DMA_ENABLE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_ENABLE_SPEC ; impl crate :: RegisterSpec for DMA_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_enable::R`](R) reader structure"]
impl crate :: Readable for DMA_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_enable::W`](W) writer structure"]
impl crate :: Writable for DMA_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_ENABLE to value 0"]
impl crate :: Resettable for DMA_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DMA_DONE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_done::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_done::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_done`]
module"]
pub type DMA_DONE = crate :: Reg < dma_done :: DMA_DONE_SPEC > ; # [doc = ""]
pub mod dma_done { # [doc = "Register `DMA_DONE` reader"]
pub type R = crate :: R < DMA_DONE_SPEC > ; # [doc = "Register `DMA_DONE` writer"]
pub type W = crate :: W < DMA_DONE_SPEC > ; # [doc = "Field `dma_done` reader - "]
pub type DMA_DONE_R = crate :: BitReader ; # [doc = "Field `dma_done` writer - "]
pub type DMA_DONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_done (& self) -> DMA_DONE_R { DMA_DONE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_done (& mut self) -> DMA_DONE_W < DMA_DONE_SPEC , 0 > { DMA_DONE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_done::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_done::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_DONE_SPEC ; impl crate :: RegisterSpec for DMA_DONE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_done::R`](R) reader structure"]
impl crate :: Readable for DMA_DONE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_done::W`](W) writer structure"]
impl crate :: Writable for DMA_DONE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_DONE to value 0"]
impl crate :: Resettable for DMA_DONE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DMA_LOOP (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_loop::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_loop::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_loop`]
module"]
pub type DMA_LOOP = crate :: Reg < dma_loop :: DMA_LOOP_SPEC > ; # [doc = ""]
pub mod dma_loop { # [doc = "Register `DMA_LOOP` reader"]
pub type R = crate :: R < DMA_LOOP_SPEC > ; # [doc = "Register `DMA_LOOP` writer"]
pub type W = crate :: W < DMA_LOOP_SPEC > ; # [doc = "Field `dma_loop` reader - "]
pub type DMA_LOOP_R = crate :: BitReader ; # [doc = "Field `dma_loop` writer - "]
pub type DMA_LOOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_loop (& self) -> DMA_LOOP_R { DMA_LOOP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_loop (& mut self) -> DMA_LOOP_W < DMA_LOOP_SPEC , 0 > { DMA_LOOP_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_loop::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_loop::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_LOOP_SPEC ; impl crate :: RegisterSpec for DMA_LOOP_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_loop::R`](R) reader structure"]
impl crate :: Readable for DMA_LOOP_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_loop::W`](W) writer structure"]
impl crate :: Writable for DMA_LOOP_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_LOOP to value 0x01"]
impl crate :: Resettable for DMA_LOOP_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "DMA_OFFSET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_offset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_offset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_offset`]
module"]
pub type DMA_OFFSET = crate :: Reg < dma_offset :: DMA_OFFSET_SPEC > ; # [doc = ""]
pub mod dma_offset { # [doc = "Register `DMA_OFFSET` reader"]
pub type R = crate :: R < DMA_OFFSET_SPEC > ; # [doc = "Register `DMA_OFFSET` writer"]
pub type W = crate :: W < DMA_OFFSET_SPEC > ; # [doc = "Field `dma_offset` reader - "]
pub type DMA_OFFSET_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_offset` writer - "]
pub type DMA_OFFSET_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_offset (& self) -> DMA_OFFSET_R { DMA_OFFSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_offset (& mut self) -> DMA_OFFSET_W < DMA_OFFSET_SPEC , 0 > { DMA_OFFSET_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_offset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_offset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_OFFSET_SPEC ; impl crate :: RegisterSpec for DMA_OFFSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_offset::R`](R) reader structure"]
impl crate :: Readable for DMA_OFFSET_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_offset::W`](W) writer structure"]
impl crate :: Writable for DMA_OFFSET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_OFFSET to value 0"]
impl crate :: Resettable for DMA_OFFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub struct VIDEO_FRAMEBUFFER_VTG { _marker : PhantomData < * const () > } unsafe impl Send for VIDEO_FRAMEBUFFER_VTG { } impl VIDEO_FRAMEBUFFER_VTG { # [doc = r"Pointer to the register block"]
pub const PTR : * const video_framebuffer_vtg :: RegisterBlock = 0xf000_6000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const video_framebuffer_vtg :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for VIDEO_FRAMEBUFFER_VTG { type Target = video_framebuffer_vtg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VIDEO_FRAMEBUFFER_VTG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VIDEO_FRAMEBUFFER_VTG") . finish () } } # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub mod video_framebuffer_vtg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub enable : ENABLE , # [doc = "0x04 - "]
pub hres : HRES , # [doc = "0x08 - "]
pub hsync_start : HSYNC_START , # [doc = "0x0c - "]
pub hsync_end : HSYNC_END , # [doc = "0x10 - "]
pub hscan : HSCAN , # [doc = "0x14 - "]
pub vres : VRES , # [doc = "0x18 - "]
pub vsync_start : VSYNC_START , # [doc = "0x1c - "]
pub vsync_end : VSYNC_END , # [doc = "0x20 - "]
pub vscan : VSCAN , } # [doc = "ENABLE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`enable`]
module"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = ""]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < ENABLE_SPEC > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < ENABLE_SPEC > ; # [doc = "Field `enable` reader - "]
pub type ENABLE_R = crate :: BitReader ; # [doc = "Field `enable` writer - "]
pub type ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < ENABLE_SPEC , 0 > { ENABLE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0x01"]
impl crate :: Resettable for ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "HRES (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hres::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hres::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hres`]
module"]
pub type HRES = crate :: Reg < hres :: HRES_SPEC > ; # [doc = ""]
pub mod hres { # [doc = "Register `HRES` reader"]
pub type R = crate :: R < HRES_SPEC > ; # [doc = "Register `HRES` writer"]
pub type W = crate :: W < HRES_SPEC > ; # [doc = "Field `hres` reader - "]
pub type HRES_R = crate :: FieldReader < u16 > ; # [doc = "Field `hres` writer - "]
pub type HRES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hres (& self) -> HRES_R { HRES_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hres (& mut self) -> HRES_W < HRES_SPEC , 0 > { HRES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hres::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hres::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HRES_SPEC ; impl crate :: RegisterSpec for HRES_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hres::R`](R) reader structure"]
impl crate :: Readable for HRES_SPEC { } # [doc = "`write(|w| ..)` method takes [`hres::W`](W) writer structure"]
impl crate :: Writable for HRES_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HRES to value 0x010a"]
impl crate :: Resettable for HRES_SPEC { const RESET_VALUE : Self :: Ux = 0x010a ; } } # [doc = "HSYNC_START (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_start::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_start::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hsync_start`]
module"]
pub type HSYNC_START = crate :: Reg < hsync_start :: HSYNC_START_SPEC > ; # [doc = ""]
pub mod hsync_start { # [doc = "Register `HSYNC_START` reader"]
pub type R = crate :: R < HSYNC_START_SPEC > ; # [doc = "Register `HSYNC_START` writer"]
pub type W = crate :: W < HSYNC_START_SPEC > ; # [doc = "Field `hsync_start` reader - "]
pub type HSYNC_START_R = crate :: FieldReader < u16 > ; # [doc = "Field `hsync_start` writer - "]
pub type HSYNC_START_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hsync_start (& self) -> HSYNC_START_R { HSYNC_START_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hsync_start (& mut self) -> HSYNC_START_W < HSYNC_START_SPEC , 0 > { HSYNC_START_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_start::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_start::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSYNC_START_SPEC ; impl crate :: RegisterSpec for HSYNC_START_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hsync_start::R`](R) reader structure"]
impl crate :: Readable for HSYNC_START_SPEC { } # [doc = "`write(|w| ..)` method takes [`hsync_start::W`](W) writer structure"]
impl crate :: Writable for HSYNC_START_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSYNC_START to value 0x0112"]
impl crate :: Resettable for HSYNC_START_SPEC { const RESET_VALUE : Self :: Ux = 0x0112 ; } } # [doc = "HSYNC_END (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hsync_end`]
module"]
pub type HSYNC_END = crate :: Reg < hsync_end :: HSYNC_END_SPEC > ; # [doc = ""]
pub mod hsync_end { # [doc = "Register `HSYNC_END` reader"]
pub type R = crate :: R < HSYNC_END_SPEC > ; # [doc = "Register `HSYNC_END` writer"]
pub type W = crate :: W < HSYNC_END_SPEC > ; # [doc = "Field `hsync_end` reader - "]
pub type HSYNC_END_R = crate :: FieldReader < u16 > ; # [doc = "Field `hsync_end` writer - "]
pub type HSYNC_END_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hsync_end (& self) -> HSYNC_END_R { HSYNC_END_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hsync_end (& mut self) -> HSYNC_END_W < HSYNC_END_SPEC , 0 > { HSYNC_END_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSYNC_END_SPEC ; impl crate :: RegisterSpec for HSYNC_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hsync_end::R`](R) reader structure"]
impl crate :: Readable for HSYNC_END_SPEC { } # [doc = "`write(|w| ..)` method takes [`hsync_end::W`](W) writer structure"]
impl crate :: Writable for HSYNC_END_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSYNC_END to value 0x0132"]
impl crate :: Resettable for HSYNC_END_SPEC { const RESET_VALUE : Self :: Ux = 0x0132 ; } } # [doc = "HSCAN (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hscan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hscan`]
module"]
pub type HSCAN = crate :: Reg < hscan :: HSCAN_SPEC > ; # [doc = ""]
pub mod hscan { # [doc = "Register `HSCAN` reader"]
pub type R = crate :: R < HSCAN_SPEC > ; # [doc = "Register `HSCAN` writer"]
pub type W = crate :: W < HSCAN_SPEC > ; # [doc = "Field `hscan` reader - "]
pub type HSCAN_R = crate :: FieldReader < u16 > ; # [doc = "Field `hscan` writer - "]
pub type HSCAN_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hscan (& self) -> HSCAN_R { HSCAN_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hscan (& mut self) -> HSCAN_W < HSCAN_SPEC , 0 > { HSCAN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hscan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSCAN_SPEC ; impl crate :: RegisterSpec for HSCAN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hscan::R`](R) reader structure"]
impl crate :: Readable for HSCAN_SPEC { } # [doc = "`write(|w| ..)` method takes [`hscan::W`](W) writer structure"]
impl crate :: Writable for HSCAN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSCAN to value 0x0153"]
impl crate :: Resettable for HSCAN_SPEC { const RESET_VALUE : Self :: Ux = 0x0153 ; } } # [doc = "VRES (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vres::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vres::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vres`]
module"]
pub type VRES = crate :: Reg < vres :: VRES_SPEC > ; # [doc = ""]
pub mod vres { # [doc = "Register `VRES` reader"]
pub type R = crate :: R < VRES_SPEC > ; # [doc = "Register `VRES` writer"]
pub type W = crate :: W < VRES_SPEC > ; # [doc = "Field `vres` reader - "]
pub type VRES_R = crate :: FieldReader < u16 > ; # [doc = "Field `vres` writer - "]
pub type VRES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vres (& self) -> VRES_R { VRES_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vres (& mut self) -> VRES_W < VRES_SPEC , 0 > { VRES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vres::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vres::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VRES_SPEC ; impl crate :: RegisterSpec for VRES_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vres::R`](R) reader structure"]
impl crate :: Readable for VRES_SPEC { } # [doc = "`write(|w| ..)` method takes [`vres::W`](W) writer structure"]
impl crate :: Writable for VRES_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VRES to value 0xf0"]
impl crate :: Resettable for VRES_SPEC { const RESET_VALUE : Self :: Ux = 0xf0 ; } } # [doc = "VSYNC_START (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_start::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_start::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_start`]
module"]
pub type VSYNC_START = crate :: Reg < vsync_start :: VSYNC_START_SPEC > ; # [doc = ""]
pub mod vsync_start { # [doc = "Register `VSYNC_START` reader"]
pub type R = crate :: R < VSYNC_START_SPEC > ; # [doc = "Register `VSYNC_START` writer"]
pub type W = crate :: W < VSYNC_START_SPEC > ; # [doc = "Field `vsync_start` reader - "]
pub type VSYNC_START_R = crate :: FieldReader < u16 > ; # [doc = "Field `vsync_start` writer - "]
pub type VSYNC_START_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vsync_start (& self) -> VSYNC_START_R { VSYNC_START_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vsync_start (& mut self) -> VSYNC_START_W < VSYNC_START_SPEC , 0 > { VSYNC_START_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_start::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_start::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_START_SPEC ; impl crate :: RegisterSpec for VSYNC_START_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_start::R`](R) reader structure"]
impl crate :: Readable for VSYNC_START_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_start::W`](W) writer structure"]
impl crate :: Writable for VSYNC_START_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_START to value 0xf1"]
impl crate :: Resettable for VSYNC_START_SPEC { const RESET_VALUE : Self :: Ux = 0xf1 ; } } # [doc = "VSYNC_END (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_end`]
module"]
pub type VSYNC_END = crate :: Reg < vsync_end :: VSYNC_END_SPEC > ; # [doc = ""]
pub mod vsync_end { # [doc = "Register `VSYNC_END` reader"]
pub type R = crate :: R < VSYNC_END_SPEC > ; # [doc = "Register `VSYNC_END` writer"]
pub type W = crate :: W < VSYNC_END_SPEC > ; # [doc = "Field `vsync_end` reader - "]
pub type VSYNC_END_R = crate :: FieldReader < u16 > ; # [doc = "Field `vsync_end` writer - "]
pub type VSYNC_END_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vsync_end (& self) -> VSYNC_END_R { VSYNC_END_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vsync_end (& mut self) -> VSYNC_END_W < VSYNC_END_SPEC , 0 > { VSYNC_END_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_END_SPEC ; impl crate :: RegisterSpec for VSYNC_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_end::R`](R) reader structure"]
impl crate :: Readable for VSYNC_END_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_end::W`](W) writer structure"]
impl crate :: Writable for VSYNC_END_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_END to value 0xf9"]
impl crate :: Resettable for VSYNC_END_SPEC { const RESET_VALUE : Self :: Ux = 0xf9 ; } } # [doc = "VSCAN (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vscan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vscan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vscan`]
module"]
pub type VSCAN = crate :: Reg < vscan :: VSCAN_SPEC > ; # [doc = ""]
pub mod vscan { # [doc = "Register `VSCAN` reader"]
pub type R = crate :: R < VSCAN_SPEC > ; # [doc = "Register `VSCAN` writer"]
pub type W = crate :: W < VSCAN_SPEC > ; # [doc = "Field `vscan` reader - "]
pub type VSCAN_R = crate :: FieldReader < u16 > ; # [doc = "Field `vscan` writer - "]
pub type VSCAN_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vscan (& self) -> VSCAN_R { VSCAN_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vscan (& mut self) -> VSCAN_W < VSCAN_SPEC , 0 > { VSCAN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vscan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vscan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSCAN_SPEC ; impl crate :: RegisterSpec for VSCAN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vscan::R`](R) reader structure"]
impl crate :: Readable for VSCAN_SPEC { } # [doc = "`write(|w| ..)` method takes [`vscan::W`](W) writer structure"]
impl crate :: Writable for VSCAN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSCAN to value 0x0117"]
impl crate :: Resettable for VSCAN_SPEC { const RESET_VALUE : Self :: Ux = 0x0117 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "APF_AUDIO"]
pub APF_AUDIO : APF_AUDIO , # [doc = "APF_BRIDGE"]
pub APF_BRIDGE : APF_BRIDGE , # [doc = "APF_ID"]
pub APF_ID : APF_ID , # [doc = "APF_INPUT"]
pub APF_INPUT : APF_INPUT , # [doc = "APF_RTC"]
pub APF_RTC : APF_RTC , # [doc = "APF_VIDEO"]
pub APF_VIDEO : APF_VIDEO , # [doc = "CTRL"]
pub CTRL : CTRL , # [doc = "IDENTIFIER_MEM"]
pub IDENTIFIER_MEM : IDENTIFIER_MEM , # [doc = "SDRAM"]
pub SDRAM : SDRAM , # [doc = "TIMER0"]
pub TIMER0 : TIMER0 , # [doc = "UART"]
pub UART : UART , # [doc = "VIDEO_FRAMEBUFFER"]
pub VIDEO_FRAMEBUFFER : VIDEO_FRAMEBUFFER , # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub VIDEO_FRAMEBUFFER_VTG : VIDEO_FRAMEBUFFER_VTG , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { APF_AUDIO : APF_AUDIO { _marker : PhantomData } , APF_BRIDGE : APF_BRIDGE { _marker : PhantomData } , APF_ID : APF_ID { _marker : PhantomData } , APF_INPUT : APF_INPUT { _marker : PhantomData } , APF_RTC : APF_RTC { _marker : PhantomData } , APF_VIDEO : APF_VIDEO { _marker : PhantomData } , CTRL : CTRL { _marker : PhantomData } , IDENTIFIER_MEM : IDENTIFIER_MEM { _marker : PhantomData } , SDRAM : SDRAM { _marker : PhantomData } , TIMER0 : TIMER0 { _marker : PhantomData } , UART : UART { _marker : PhantomData } , VIDEO_FRAMEBUFFER : VIDEO_FRAMEBUFFER { _marker : PhantomData } , VIDEO_FRAMEBUFFER_VTG : VIDEO_FRAMEBUFFER_VTG { _marker : PhantomData } , } } }