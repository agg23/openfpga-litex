# ! [doc = "Peripheral access API for SOC microcontrollers (generated using svd2rust v0.30.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.30.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_bounds)]
# ! [deny (private_interfaces)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + PartialEq + From < Self > ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { self . register . set (f (& mut W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ,) ; } } # [doc (hidden)]
pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct FieldWriter < 'a , REG , const WI : u8 , const O : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , const O : u8 , FI , Safety > FieldWriter < 'a , REG , WI , O , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG >) -> Self { Self { w , _field : marker :: PhantomData , } } } pub struct BitWriter < 'a , REG , const O : u8 , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , const O : u8 , FI , M > BitWriter < 'a , REG , O , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG >) -> Self { Self { w , _field : marker :: PhantomData , } } } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub type W < REG > = raw :: W < REG > ; # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> FI :: Ux { self . bits } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , O , FI , Unsafe > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , REG , const WI : u8 , const O : u8 , FI = u8 > = raw :: FieldWriter < 'a , REG , WI , O , FI , Safe > ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , const O : u8 , FI = bool > = raw :: BitWriter <'a , REG , O , FI , $ mwv >; impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , REG , const OF : u8 , FI > $ writer <'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriter < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } impl < 'a , REG , const WI : u8 , const OF : u8 , FI > FieldWriterSafe < 'a , REG , WI , OF , FI > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << OF) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { self . bits (FI :: Ux :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , REG , const OF : u8 , FI > BitWriter < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1C < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0S < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter1T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << OF ; self . w } } impl < 'a , REG , const OF : u8 , FI > BitWriter0T < 'a , REG , OF , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << OF) ; self . w } } } # [cfg (feature = "rt")]
extern "C" { fn UART () ; fn TIMER0 () ; } # [doc (hidden)]
pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [no_mangle]
pub static __EXTERNAL_INTERRUPTS : [Vector ; 3]
= [Vector { _reserved : 0 } , Vector { _handler : UART } , Vector { _handler : TIMER0 } ,]
; # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "1 - uart"]
UART = 1 , # [doc = "2 - timer0"]
TIMER0 = 2 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 1 => Ok (Interrupt :: UART) , 2 => Ok (Interrupt :: TIMER0) , _ => Err (TryFromInterruptError (())) , } } } # [cfg (feature = "rt")]
# [macro_export]
# [doc = r" Assigns a handler to an interrupt"]
# [doc = r""]
# [doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
# [doc = r" function that will be used as the handler of that interrupt. That function"]
# [doc = r" must have signature `fn()`."]
# [doc = r""]
# [doc = r" Optionally, a third argument may be used to declare interrupt local data."]
# [doc = r" The handler will have exclusive access to these *local* variables on each"]
# [doc = r" invocation. If the third argument is used then the signature of the handler"]
# [doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
# [doc = r" passed to the macro."]
# [doc = r""]
# [doc = r" # Example"]
# [doc = r""]
# [doc = r" ``` ignore"]
# [doc = r" interrupt!(TIM2, periodic);"]
# [doc = r""]
# [doc = r" fn periodic() {"]
# [doc = r#"     print!(".");"#]
# [doc = r" }"]
# [doc = r""]
# [doc = r" interrupt!(TIM3, tick, locals: {"]
# [doc = r"     tick: bool = false;"]
# [doc = r" });"]
# [doc = r""]
# [doc = r" fn tick(locals: &mut TIM3::Locals) {"]
# [doc = r"     locals.tick = !locals.tick;"]
# [doc = r""]
# [doc = r"     if locals.tick {"]
# [doc = r#"         println!("Tick");"#]
# [doc = r"     } else {"]
# [doc = r#"         println!("Tock");"#]
# [doc = r"     }"]
# [doc = r" }"]
# [doc = r" ```"]
macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } } } pub use self :: interrupt :: Interrupt ; # [doc = "CTRL"]
pub struct CTRL { _marker : PhantomData < * const () > } unsafe impl Send for CTRL { } impl CTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const ctrl :: RegisterBlock = 0xf000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ctrl :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for CTRL { type Target = ctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CTRL") . finish () } } # [doc = "CTRL"]
pub mod ctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub reset : RESET , # [doc = "0x04 - Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
pub scratch : SCRATCH , # [doc = "0x08 - Total number of Wishbone bus errors (timeouts) since start."]
pub bus_errors : BUS_ERRORS , } # [doc = "RESET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`reset`]
module"]
pub type RESET = crate :: Reg < reset :: RESET_SPEC > ; # [doc = ""]
pub mod reset { # [doc = "Register `RESET` reader"]
pub type R = crate :: R < RESET_SPEC > ; # [doc = "Register `RESET` writer"]
pub type W = crate :: W < RESET_SPEC > ; # [doc = "Field `soc_rst` reader - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SOC_RST_R = crate :: BitReader ; # [doc = "Field `soc_rst` writer - Write `1` to this register to reset the full SoC (Pulse Reset)"]
pub type SOC_RST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cpu_rst` reader - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CPU_RST_R = crate :: BitReader ; # [doc = "Field `cpu_rst` writer - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
pub type CPU_RST_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
pub fn soc_rst (& self) -> SOC_RST_R { SOC_RST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
pub fn cpu_rst (& self) -> CPU_RST_R { CPU_RST_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write `1` to this register to reset the full SoC (Pulse Reset)"]
# [inline (always)]
# [must_use]
pub fn soc_rst (& mut self) -> SOC_RST_W < RESET_SPEC , 0 > { SOC_RST_W :: new (self) } # [doc = "Bit 1 - Write `1` to this register to reset the CPU(s) of the SoC (Hold Reset)"]
# [inline (always)]
# [must_use]
pub fn cpu_rst (& mut self) -> CPU_RST_W < RESET_SPEC , 1 > { CPU_RST_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RESET_SPEC ; impl crate :: RegisterSpec for RESET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`reset::R`](R) reader structure"]
impl crate :: Readable for RESET_SPEC { } # [doc = "`write(|w| ..)` method takes [`reset::W`](W) writer structure"]
impl crate :: Writable for RESET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RESET to value 0"]
impl crate :: Resettable for RESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCRATCH (rw) register accessor: Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`scratch`]
module"]
pub type SCRATCH = crate :: Reg < scratch :: SCRATCH_SPEC > ; # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness."]
pub mod scratch { # [doc = "Register `SCRATCH` reader"]
pub type R = crate :: R < SCRATCH_SPEC > ; # [doc = "Register `SCRATCH` writer"]
pub type W = crate :: W < SCRATCH_SPEC > ; # [doc = "Field `scratch` reader - "]
pub type SCRATCH_R = crate :: FieldReader < u32 > ; # [doc = "Field `scratch` writer - "]
pub type SCRATCH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn scratch (& self) -> SCRATCH_R { SCRATCH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn scratch (& mut self) -> SCRATCH_W < SCRATCH_SPEC , 0 > { SCRATCH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`scratch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`scratch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SCRATCH_SPEC ; impl crate :: RegisterSpec for SCRATCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`scratch::R`](R) reader structure"]
impl crate :: Readable for SCRATCH_SPEC { } # [doc = "`write(|w| ..)` method takes [`scratch::W`](W) writer structure"]
impl crate :: Writable for SCRATCH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCRATCH to value 0x1234_5678"]
impl crate :: Resettable for SCRATCH_SPEC { const RESET_VALUE : Self :: Ux = 0x1234_5678 ; } } # [doc = "BUS_ERRORS (rw) register accessor: Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bus_errors`]
module"]
pub type BUS_ERRORS = crate :: Reg < bus_errors :: BUS_ERRORS_SPEC > ; # [doc = "Total number of Wishbone bus errors (timeouts) since start."]
pub mod bus_errors { # [doc = "Register `BUS_ERRORS` reader"]
pub type R = crate :: R < BUS_ERRORS_SPEC > ; # [doc = "Register `BUS_ERRORS` writer"]
pub type W = crate :: W < BUS_ERRORS_SPEC > ; # [doc = "Field `bus_errors` reader - "]
pub type BUS_ERRORS_R = crate :: FieldReader < u32 > ; # [doc = "Field `bus_errors` writer - "]
pub type BUS_ERRORS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bus_errors (& self) -> BUS_ERRORS_R { BUS_ERRORS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bus_errors (& mut self) -> BUS_ERRORS_W < BUS_ERRORS_SPEC , 0 > { BUS_ERRORS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Total number of Wishbone bus errors (timeouts) since start.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bus_errors::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bus_errors::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BUS_ERRORS_SPEC ; impl crate :: RegisterSpec for BUS_ERRORS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bus_errors::R`](R) reader structure"]
impl crate :: Readable for BUS_ERRORS_SPEC { } # [doc = "`write(|w| ..)` method takes [`bus_errors::W`](W) writer structure"]
impl crate :: Writable for BUS_ERRORS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BUS_ERRORS to value 0"]
impl crate :: Resettable for BUS_ERRORS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "IDENTIFIER_MEM"]
pub struct IDENTIFIER_MEM { _marker : PhantomData < * const () > } unsafe impl Send for IDENTIFIER_MEM { } impl IDENTIFIER_MEM { # [doc = r"Pointer to the register block"]
pub const PTR : * const identifier_mem :: RegisterBlock = 0xf000_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const identifier_mem :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for IDENTIFIER_MEM { type Target = identifier_mem :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IDENTIFIER_MEM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IDENTIFIER_MEM") . finish () } } # [doc = "IDENTIFIER_MEM"]
pub mod identifier_mem { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - 8 x 47-bit memory"]
pub identifier_mem : IDENTIFIER_MEM , } # [doc = "IDENTIFIER_MEM (rw) register accessor: 8 x 47-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`identifier_mem`]
module"]
pub type IDENTIFIER_MEM = crate :: Reg < identifier_mem :: IDENTIFIER_MEM_SPEC > ; # [doc = "8 x 47-bit memory"]
pub mod identifier_mem { # [doc = "Register `IDENTIFIER_MEM` reader"]
pub type R = crate :: R < IDENTIFIER_MEM_SPEC > ; # [doc = "Register `IDENTIFIER_MEM` writer"]
pub type W = crate :: W < IDENTIFIER_MEM_SPEC > ; # [doc = "Field `identifier_mem` reader - "]
pub type IDENTIFIER_MEM_R = crate :: FieldReader ; # [doc = "Field `identifier_mem` writer - "]
pub type IDENTIFIER_MEM_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 8 , O > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn identifier_mem (& self) -> IDENTIFIER_MEM_R { IDENTIFIER_MEM_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn identifier_mem (& mut self) -> IDENTIFIER_MEM_W < IDENTIFIER_MEM_SPEC , 0 > { IDENTIFIER_MEM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "8 x 47-bit memory\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`identifier_mem::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`identifier_mem::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IDENTIFIER_MEM_SPEC ; impl crate :: RegisterSpec for IDENTIFIER_MEM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`identifier_mem::R`](R) reader structure"]
impl crate :: Readable for IDENTIFIER_MEM_SPEC { } # [doc = "`write(|w| ..)` method takes [`identifier_mem::W`](W) writer structure"]
impl crate :: Writable for IDENTIFIER_MEM_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IDENTIFIER_MEM to value 0"]
impl crate :: Resettable for IDENTIFIER_MEM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "MAIN"]
pub struct MAIN { _marker : PhantomData < * const () > } unsafe impl Send for MAIN { } impl MAIN { # [doc = r"Pointer to the register block"]
pub const PTR : * const main :: RegisterBlock = 0xf000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const main :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for MAIN { type Target = main :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MAIN { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MAIN") . finish () } } # [doc = "MAIN"]
pub mod main { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub cont1_key : CONT1_KEY , # [doc = "0x04 - "]
pub cont2_key : CONT2_KEY , # [doc = "0x08 - "]
pub cont3_key : CONT3_KEY , # [doc = "0x0c - "]
pub cont4_key : CONT4_KEY , # [doc = "0x10 - "]
pub cont1_joy : CONT1_JOY , # [doc = "0x14 - "]
pub cont2_joy : CONT2_JOY , # [doc = "0x18 - "]
pub cont3_joy : CONT3_JOY , # [doc = "0x1c - "]
pub cont4_joy : CONT4_JOY , # [doc = "0x20 - "]
pub cont1_trig : CONT1_TRIG , # [doc = "0x24 - "]
pub cont2_trig : CONT2_TRIG , # [doc = "0x28 - "]
pub cont3_trig : CONT3_TRIG , # [doc = "0x2c - "]
pub cont4_trig : CONT4_TRIG , # [doc = "0x30 - "]
pub bridge_request_read : BRIDGE_REQUEST_READ , # [doc = "0x34 - "]
pub bridge_slot_id : BRIDGE_SLOT_ID , # [doc = "0x38 - "]
pub bridge_data_offset : BRIDGE_DATA_OFFSET , # [doc = "0x3c - "]
pub bridge_length : BRIDGE_LENGTH , # [doc = "0x40 - "]
pub ram_data_address : RAM_DATA_ADDRESS , # [doc = "0x44 - "]
pub bridge_file_size : BRIDGE_FILE_SIZE , # [doc = "0x48 - "]
pub bridge_status : BRIDGE_STATUS , # [doc = "0x4c - "]
pub bridge_current_address : BRIDGE_CURRENT_ADDRESS , # [doc = "0x50 - "]
pub vsync_status : VSYNC_STATUS , # [doc = "0x54 - "]
pub vblank_status : VBLANK_STATUS , # [doc = "0x58 - "]
pub frame_counter : FRAME_COUNTER , # [doc = "0x5c - "]
pub audio_out : AUDIO_OUT , # [doc = "0x60 - "]
pub audio_playback_en : AUDIO_PLAYBACK_EN , # [doc = "0x64 - "]
pub audio_buffer_flush : AUDIO_BUFFER_FLUSH , # [doc = "0x68 - "]
pub audio_buffer_fill : AUDIO_BUFFER_FILL , # [doc = "0x6c - "]
pub rtc_unix_seconds : RTC_UNIX_SECONDS , # [doc = "0x70 - "]
pub rtc_date_bcd : RTC_DATE_BCD , # [doc = "0x74 - "]
pub rtc_time_bcd : RTC_TIME_BCD , # [doc = "0x78 - Bits 32-63 of `MAIN_CHIP_ID`."]
pub chip_id1 : CHIP_ID1 , # [doc = "0x7c - Bits 0-31 of `MAIN_CHIP_ID`."]
pub chip_id0 : CHIP_ID0 , } # [doc = "CONT1_KEY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_key`]
module"]
pub type CONT1_KEY = crate :: Reg < cont1_key :: CONT1_KEY_SPEC > ; # [doc = ""]
pub mod cont1_key { # [doc = "Register `CONT1_KEY` reader"]
pub type R = crate :: R < CONT1_KEY_SPEC > ; # [doc = "Register `CONT1_KEY` writer"]
pub type W = crate :: W < CONT1_KEY_SPEC > ; # [doc = "Field `cont1_key` reader - "]
pub type CONT1_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_key` writer - "]
pub type CONT1_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_key (& self) -> CONT1_KEY_R { CONT1_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_key (& mut self) -> CONT1_KEY_W < CONT1_KEY_SPEC , 0 > { CONT1_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_KEY_SPEC ; impl crate :: RegisterSpec for CONT1_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_key::R`](R) reader structure"]
impl crate :: Readable for CONT1_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_key::W`](W) writer structure"]
impl crate :: Writable for CONT1_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_KEY to value 0"]
impl crate :: Resettable for CONT1_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_KEY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_key`]
module"]
pub type CONT2_KEY = crate :: Reg < cont2_key :: CONT2_KEY_SPEC > ; # [doc = ""]
pub mod cont2_key { # [doc = "Register `CONT2_KEY` reader"]
pub type R = crate :: R < CONT2_KEY_SPEC > ; # [doc = "Register `CONT2_KEY` writer"]
pub type W = crate :: W < CONT2_KEY_SPEC > ; # [doc = "Field `cont2_key` reader - "]
pub type CONT2_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_key` writer - "]
pub type CONT2_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_key (& self) -> CONT2_KEY_R { CONT2_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_key (& mut self) -> CONT2_KEY_W < CONT2_KEY_SPEC , 0 > { CONT2_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_KEY_SPEC ; impl crate :: RegisterSpec for CONT2_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_key::R`](R) reader structure"]
impl crate :: Readable for CONT2_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_key::W`](W) writer structure"]
impl crate :: Writable for CONT2_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_KEY to value 0"]
impl crate :: Resettable for CONT2_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_KEY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_key`]
module"]
pub type CONT3_KEY = crate :: Reg < cont3_key :: CONT3_KEY_SPEC > ; # [doc = ""]
pub mod cont3_key { # [doc = "Register `CONT3_KEY` reader"]
pub type R = crate :: R < CONT3_KEY_SPEC > ; # [doc = "Register `CONT3_KEY` writer"]
pub type W = crate :: W < CONT3_KEY_SPEC > ; # [doc = "Field `cont3_key` reader - "]
pub type CONT3_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_key` writer - "]
pub type CONT3_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_key (& self) -> CONT3_KEY_R { CONT3_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_key (& mut self) -> CONT3_KEY_W < CONT3_KEY_SPEC , 0 > { CONT3_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_KEY_SPEC ; impl crate :: RegisterSpec for CONT3_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_key::R`](R) reader structure"]
impl crate :: Readable for CONT3_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_key::W`](W) writer structure"]
impl crate :: Writable for CONT3_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_KEY to value 0"]
impl crate :: Resettable for CONT3_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_KEY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_key::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_key::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_key`]
module"]
pub type CONT4_KEY = crate :: Reg < cont4_key :: CONT4_KEY_SPEC > ; # [doc = ""]
pub mod cont4_key { # [doc = "Register `CONT4_KEY` reader"]
pub type R = crate :: R < CONT4_KEY_SPEC > ; # [doc = "Register `CONT4_KEY` writer"]
pub type W = crate :: W < CONT4_KEY_SPEC > ; # [doc = "Field `cont4_key` reader - "]
pub type CONT4_KEY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_key` writer - "]
pub type CONT4_KEY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_key (& self) -> CONT4_KEY_R { CONT4_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_key (& mut self) -> CONT4_KEY_W < CONT4_KEY_SPEC , 0 > { CONT4_KEY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_key::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_key::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_KEY_SPEC ; impl crate :: RegisterSpec for CONT4_KEY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_key::R`](R) reader structure"]
impl crate :: Readable for CONT4_KEY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_key::W`](W) writer structure"]
impl crate :: Writable for CONT4_KEY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_KEY to value 0"]
impl crate :: Resettable for CONT4_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT1_JOY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_joy`]
module"]
pub type CONT1_JOY = crate :: Reg < cont1_joy :: CONT1_JOY_SPEC > ; # [doc = ""]
pub mod cont1_joy { # [doc = "Register `CONT1_JOY` reader"]
pub type R = crate :: R < CONT1_JOY_SPEC > ; # [doc = "Register `CONT1_JOY` writer"]
pub type W = crate :: W < CONT1_JOY_SPEC > ; # [doc = "Field `cont1_joy` reader - "]
pub type CONT1_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_joy` writer - "]
pub type CONT1_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_joy (& self) -> CONT1_JOY_R { CONT1_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_joy (& mut self) -> CONT1_JOY_W < CONT1_JOY_SPEC , 0 > { CONT1_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_JOY_SPEC ; impl crate :: RegisterSpec for CONT1_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_joy::R`](R) reader structure"]
impl crate :: Readable for CONT1_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_joy::W`](W) writer structure"]
impl crate :: Writable for CONT1_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_JOY to value 0"]
impl crate :: Resettable for CONT1_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_JOY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_joy`]
module"]
pub type CONT2_JOY = crate :: Reg < cont2_joy :: CONT2_JOY_SPEC > ; # [doc = ""]
pub mod cont2_joy { # [doc = "Register `CONT2_JOY` reader"]
pub type R = crate :: R < CONT2_JOY_SPEC > ; # [doc = "Register `CONT2_JOY` writer"]
pub type W = crate :: W < CONT2_JOY_SPEC > ; # [doc = "Field `cont2_joy` reader - "]
pub type CONT2_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_joy` writer - "]
pub type CONT2_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_joy (& self) -> CONT2_JOY_R { CONT2_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_joy (& mut self) -> CONT2_JOY_W < CONT2_JOY_SPEC , 0 > { CONT2_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_JOY_SPEC ; impl crate :: RegisterSpec for CONT2_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_joy::R`](R) reader structure"]
impl crate :: Readable for CONT2_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_joy::W`](W) writer structure"]
impl crate :: Writable for CONT2_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_JOY to value 0"]
impl crate :: Resettable for CONT2_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_JOY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_joy`]
module"]
pub type CONT3_JOY = crate :: Reg < cont3_joy :: CONT3_JOY_SPEC > ; # [doc = ""]
pub mod cont3_joy { # [doc = "Register `CONT3_JOY` reader"]
pub type R = crate :: R < CONT3_JOY_SPEC > ; # [doc = "Register `CONT3_JOY` writer"]
pub type W = crate :: W < CONT3_JOY_SPEC > ; # [doc = "Field `cont3_joy` reader - "]
pub type CONT3_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_joy` writer - "]
pub type CONT3_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_joy (& self) -> CONT3_JOY_R { CONT3_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_joy (& mut self) -> CONT3_JOY_W < CONT3_JOY_SPEC , 0 > { CONT3_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_JOY_SPEC ; impl crate :: RegisterSpec for CONT3_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_joy::R`](R) reader structure"]
impl crate :: Readable for CONT3_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_joy::W`](W) writer structure"]
impl crate :: Writable for CONT3_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_JOY to value 0"]
impl crate :: Resettable for CONT3_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_JOY (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_joy::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_joy::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_joy`]
module"]
pub type CONT4_JOY = crate :: Reg < cont4_joy :: CONT4_JOY_SPEC > ; # [doc = ""]
pub mod cont4_joy { # [doc = "Register `CONT4_JOY` reader"]
pub type R = crate :: R < CONT4_JOY_SPEC > ; # [doc = "Register `CONT4_JOY` writer"]
pub type W = crate :: W < CONT4_JOY_SPEC > ; # [doc = "Field `cont4_joy` reader - "]
pub type CONT4_JOY_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_joy` writer - "]
pub type CONT4_JOY_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_joy (& self) -> CONT4_JOY_R { CONT4_JOY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_joy (& mut self) -> CONT4_JOY_W < CONT4_JOY_SPEC , 0 > { CONT4_JOY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_joy::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_joy::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_JOY_SPEC ; impl crate :: RegisterSpec for CONT4_JOY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_joy::R`](R) reader structure"]
impl crate :: Readable for CONT4_JOY_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_joy::W`](W) writer structure"]
impl crate :: Writable for CONT4_JOY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_JOY to value 0"]
impl crate :: Resettable for CONT4_JOY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT1_TRIG (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont1_trig`]
module"]
pub type CONT1_TRIG = crate :: Reg < cont1_trig :: CONT1_TRIG_SPEC > ; # [doc = ""]
pub mod cont1_trig { # [doc = "Register `CONT1_TRIG` reader"]
pub type R = crate :: R < CONT1_TRIG_SPEC > ; # [doc = "Register `CONT1_TRIG` writer"]
pub type W = crate :: W < CONT1_TRIG_SPEC > ; # [doc = "Field `cont1_trig` reader - "]
pub type CONT1_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont1_trig` writer - "]
pub type CONT1_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont1_trig (& self) -> CONT1_TRIG_R { CONT1_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont1_trig (& mut self) -> CONT1_TRIG_W < CONT1_TRIG_SPEC , 0 > { CONT1_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont1_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont1_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT1_TRIG_SPEC ; impl crate :: RegisterSpec for CONT1_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont1_trig::R`](R) reader structure"]
impl crate :: Readable for CONT1_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont1_trig::W`](W) writer structure"]
impl crate :: Writable for CONT1_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT1_TRIG to value 0"]
impl crate :: Resettable for CONT1_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT2_TRIG (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont2_trig`]
module"]
pub type CONT2_TRIG = crate :: Reg < cont2_trig :: CONT2_TRIG_SPEC > ; # [doc = ""]
pub mod cont2_trig { # [doc = "Register `CONT2_TRIG` reader"]
pub type R = crate :: R < CONT2_TRIG_SPEC > ; # [doc = "Register `CONT2_TRIG` writer"]
pub type W = crate :: W < CONT2_TRIG_SPEC > ; # [doc = "Field `cont2_trig` reader - "]
pub type CONT2_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont2_trig` writer - "]
pub type CONT2_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont2_trig (& self) -> CONT2_TRIG_R { CONT2_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont2_trig (& mut self) -> CONT2_TRIG_W < CONT2_TRIG_SPEC , 0 > { CONT2_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont2_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont2_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT2_TRIG_SPEC ; impl crate :: RegisterSpec for CONT2_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont2_trig::R`](R) reader structure"]
impl crate :: Readable for CONT2_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont2_trig::W`](W) writer structure"]
impl crate :: Writable for CONT2_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT2_TRIG to value 0"]
impl crate :: Resettable for CONT2_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT3_TRIG (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont3_trig`]
module"]
pub type CONT3_TRIG = crate :: Reg < cont3_trig :: CONT3_TRIG_SPEC > ; # [doc = ""]
pub mod cont3_trig { # [doc = "Register `CONT3_TRIG` reader"]
pub type R = crate :: R < CONT3_TRIG_SPEC > ; # [doc = "Register `CONT3_TRIG` writer"]
pub type W = crate :: W < CONT3_TRIG_SPEC > ; # [doc = "Field `cont3_trig` reader - "]
pub type CONT3_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont3_trig` writer - "]
pub type CONT3_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont3_trig (& self) -> CONT3_TRIG_R { CONT3_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont3_trig (& mut self) -> CONT3_TRIG_W < CONT3_TRIG_SPEC , 0 > { CONT3_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont3_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont3_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT3_TRIG_SPEC ; impl crate :: RegisterSpec for CONT3_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont3_trig::R`](R) reader structure"]
impl crate :: Readable for CONT3_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont3_trig::W`](W) writer structure"]
impl crate :: Writable for CONT3_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT3_TRIG to value 0"]
impl crate :: Resettable for CONT3_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CONT4_TRIG (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_trig::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_trig::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`cont4_trig`]
module"]
pub type CONT4_TRIG = crate :: Reg < cont4_trig :: CONT4_TRIG_SPEC > ; # [doc = ""]
pub mod cont4_trig { # [doc = "Register `CONT4_TRIG` reader"]
pub type R = crate :: R < CONT4_TRIG_SPEC > ; # [doc = "Register `CONT4_TRIG` writer"]
pub type W = crate :: W < CONT4_TRIG_SPEC > ; # [doc = "Field `cont4_trig` reader - "]
pub type CONT4_TRIG_R = crate :: FieldReader < u32 > ; # [doc = "Field `cont4_trig` writer - "]
pub type CONT4_TRIG_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn cont4_trig (& self) -> CONT4_TRIG_R { CONT4_TRIG_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn cont4_trig (& mut self) -> CONT4_TRIG_W < CONT4_TRIG_SPEC , 0 > { CONT4_TRIG_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cont4_trig::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cont4_trig::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CONT4_TRIG_SPEC ; impl crate :: RegisterSpec for CONT4_TRIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`cont4_trig::R`](R) reader structure"]
impl crate :: Readable for CONT4_TRIG_SPEC { } # [doc = "`write(|w| ..)` method takes [`cont4_trig::W`](W) writer structure"]
impl crate :: Writable for CONT4_TRIG_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CONT4_TRIG to value 0"]
impl crate :: Resettable for CONT4_TRIG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_REQUEST_READ (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_request_read::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_request_read::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_request_read`]
module"]
pub type BRIDGE_REQUEST_READ = crate :: Reg < bridge_request_read :: BRIDGE_REQUEST_READ_SPEC > ; # [doc = ""]
pub mod bridge_request_read { # [doc = "Register `BRIDGE_REQUEST_READ` reader"]
pub type R = crate :: R < BRIDGE_REQUEST_READ_SPEC > ; # [doc = "Register `BRIDGE_REQUEST_READ` writer"]
pub type W = crate :: W < BRIDGE_REQUEST_READ_SPEC > ; # [doc = "Field `bridge_request_read` reader - "]
pub type BRIDGE_REQUEST_READ_R = crate :: BitReader ; # [doc = "Field `bridge_request_read` writer - "]
pub type BRIDGE_REQUEST_READ_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn bridge_request_read (& self) -> BRIDGE_REQUEST_READ_R { BRIDGE_REQUEST_READ_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn bridge_request_read (& mut self) -> BRIDGE_REQUEST_READ_W < BRIDGE_REQUEST_READ_SPEC , 0 > { BRIDGE_REQUEST_READ_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_request_read::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_request_read::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_REQUEST_READ_SPEC ; impl crate :: RegisterSpec for BRIDGE_REQUEST_READ_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_request_read::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_REQUEST_READ_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_request_read::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_REQUEST_READ_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_REQUEST_READ to value 0"]
impl crate :: Resettable for BRIDGE_REQUEST_READ_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_SLOT_ID (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_slot_id::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_slot_id::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_slot_id`]
module"]
pub type BRIDGE_SLOT_ID = crate :: Reg < bridge_slot_id :: BRIDGE_SLOT_ID_SPEC > ; # [doc = ""]
pub mod bridge_slot_id { # [doc = "Register `BRIDGE_SLOT_ID` reader"]
pub type R = crate :: R < BRIDGE_SLOT_ID_SPEC > ; # [doc = "Register `BRIDGE_SLOT_ID` writer"]
pub type W = crate :: W < BRIDGE_SLOT_ID_SPEC > ; # [doc = "Field `bridge_slot_id` reader - "]
pub type BRIDGE_SLOT_ID_R = crate :: FieldReader < u16 > ; # [doc = "Field `bridge_slot_id` writer - "]
pub type BRIDGE_SLOT_ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn bridge_slot_id (& self) -> BRIDGE_SLOT_ID_R { BRIDGE_SLOT_ID_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn bridge_slot_id (& mut self) -> BRIDGE_SLOT_ID_W < BRIDGE_SLOT_ID_SPEC , 0 > { BRIDGE_SLOT_ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_slot_id::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_slot_id::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_SLOT_ID_SPEC ; impl crate :: RegisterSpec for BRIDGE_SLOT_ID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_slot_id::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_SLOT_ID_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_slot_id::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_SLOT_ID_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_SLOT_ID to value 0"]
impl crate :: Resettable for BRIDGE_SLOT_ID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_DATA_OFFSET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_data_offset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_data_offset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_data_offset`]
module"]
pub type BRIDGE_DATA_OFFSET = crate :: Reg < bridge_data_offset :: BRIDGE_DATA_OFFSET_SPEC > ; # [doc = ""]
pub mod bridge_data_offset { # [doc = "Register `BRIDGE_DATA_OFFSET` reader"]
pub type R = crate :: R < BRIDGE_DATA_OFFSET_SPEC > ; # [doc = "Register `BRIDGE_DATA_OFFSET` writer"]
pub type W = crate :: W < BRIDGE_DATA_OFFSET_SPEC > ; # [doc = "Field `bridge_data_offset` reader - "]
pub type BRIDGE_DATA_OFFSET_R = crate :: FieldReader < u32 > ; # [doc = "Field `bridge_data_offset` writer - "]
pub type BRIDGE_DATA_OFFSET_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bridge_data_offset (& self) -> BRIDGE_DATA_OFFSET_R { BRIDGE_DATA_OFFSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bridge_data_offset (& mut self) -> BRIDGE_DATA_OFFSET_W < BRIDGE_DATA_OFFSET_SPEC , 0 > { BRIDGE_DATA_OFFSET_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_data_offset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_data_offset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_DATA_OFFSET_SPEC ; impl crate :: RegisterSpec for BRIDGE_DATA_OFFSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_data_offset::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_DATA_OFFSET_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_data_offset::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_DATA_OFFSET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_DATA_OFFSET to value 0"]
impl crate :: Resettable for BRIDGE_DATA_OFFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_LENGTH (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_length::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_length::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_length`]
module"]
pub type BRIDGE_LENGTH = crate :: Reg < bridge_length :: BRIDGE_LENGTH_SPEC > ; # [doc = ""]
pub mod bridge_length { # [doc = "Register `BRIDGE_LENGTH` reader"]
pub type R = crate :: R < BRIDGE_LENGTH_SPEC > ; # [doc = "Register `BRIDGE_LENGTH` writer"]
pub type W = crate :: W < BRIDGE_LENGTH_SPEC > ; # [doc = "Field `bridge_length` reader - "]
pub type BRIDGE_LENGTH_R = crate :: FieldReader < u32 > ; # [doc = "Field `bridge_length` writer - "]
pub type BRIDGE_LENGTH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bridge_length (& self) -> BRIDGE_LENGTH_R { BRIDGE_LENGTH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bridge_length (& mut self) -> BRIDGE_LENGTH_W < BRIDGE_LENGTH_SPEC , 0 > { BRIDGE_LENGTH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_length::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_length::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_LENGTH_SPEC ; impl crate :: RegisterSpec for BRIDGE_LENGTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_length::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_LENGTH_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_length::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_LENGTH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_LENGTH to value 0"]
impl crate :: Resettable for BRIDGE_LENGTH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAM_DATA_ADDRESS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ram_data_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ram_data_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ram_data_address`]
module"]
pub type RAM_DATA_ADDRESS = crate :: Reg < ram_data_address :: RAM_DATA_ADDRESS_SPEC > ; # [doc = ""]
pub mod ram_data_address { # [doc = "Register `RAM_DATA_ADDRESS` reader"]
pub type R = crate :: R < RAM_DATA_ADDRESS_SPEC > ; # [doc = "Register `RAM_DATA_ADDRESS` writer"]
pub type W = crate :: W < RAM_DATA_ADDRESS_SPEC > ; # [doc = "Field `ram_data_address` reader - "]
pub type RAM_DATA_ADDRESS_R = crate :: FieldReader < u32 > ; # [doc = "Field `ram_data_address` writer - "]
pub type RAM_DATA_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn ram_data_address (& self) -> RAM_DATA_ADDRESS_R { RAM_DATA_ADDRESS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn ram_data_address (& mut self) -> RAM_DATA_ADDRESS_W < RAM_DATA_ADDRESS_SPEC , 0 > { RAM_DATA_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ram_data_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ram_data_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RAM_DATA_ADDRESS_SPEC ; impl crate :: RegisterSpec for RAM_DATA_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ram_data_address::R`](R) reader structure"]
impl crate :: Readable for RAM_DATA_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ram_data_address::W`](W) writer structure"]
impl crate :: Writable for RAM_DATA_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAM_DATA_ADDRESS to value 0"]
impl crate :: Resettable for RAM_DATA_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_FILE_SIZE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_file_size::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_file_size::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_file_size`]
module"]
pub type BRIDGE_FILE_SIZE = crate :: Reg < bridge_file_size :: BRIDGE_FILE_SIZE_SPEC > ; # [doc = ""]
pub mod bridge_file_size { # [doc = "Register `BRIDGE_FILE_SIZE` reader"]
pub type R = crate :: R < BRIDGE_FILE_SIZE_SPEC > ; # [doc = "Register `BRIDGE_FILE_SIZE` writer"]
pub type W = crate :: W < BRIDGE_FILE_SIZE_SPEC > ; # [doc = "Field `bridge_file_size` reader - "]
pub type BRIDGE_FILE_SIZE_R = crate :: FieldReader < u32 > ; # [doc = "Field `bridge_file_size` writer - "]
pub type BRIDGE_FILE_SIZE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bridge_file_size (& self) -> BRIDGE_FILE_SIZE_R { BRIDGE_FILE_SIZE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bridge_file_size (& mut self) -> BRIDGE_FILE_SIZE_W < BRIDGE_FILE_SIZE_SPEC , 0 > { BRIDGE_FILE_SIZE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_file_size::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_file_size::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_FILE_SIZE_SPEC ; impl crate :: RegisterSpec for BRIDGE_FILE_SIZE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_file_size::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_FILE_SIZE_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_file_size::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_FILE_SIZE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_FILE_SIZE to value 0"]
impl crate :: Resettable for BRIDGE_FILE_SIZE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_STATUS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_status`]
module"]
pub type BRIDGE_STATUS = crate :: Reg < bridge_status :: BRIDGE_STATUS_SPEC > ; # [doc = ""]
pub mod bridge_status { # [doc = "Register `BRIDGE_STATUS` reader"]
pub type R = crate :: R < BRIDGE_STATUS_SPEC > ; # [doc = "Register `BRIDGE_STATUS` writer"]
pub type W = crate :: W < BRIDGE_STATUS_SPEC > ; # [doc = "Field `bridge_status` reader - "]
pub type BRIDGE_STATUS_R = crate :: BitReader ; # [doc = "Field `bridge_status` writer - "]
pub type BRIDGE_STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn bridge_status (& self) -> BRIDGE_STATUS_R { BRIDGE_STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn bridge_status (& mut self) -> BRIDGE_STATUS_W < BRIDGE_STATUS_SPEC , 0 > { BRIDGE_STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_STATUS_SPEC ; impl crate :: RegisterSpec for BRIDGE_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_status::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_status::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_STATUS to value 0"]
impl crate :: Resettable for BRIDGE_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BRIDGE_CURRENT_ADDRESS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_current_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_current_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`bridge_current_address`]
module"]
pub type BRIDGE_CURRENT_ADDRESS = crate :: Reg < bridge_current_address :: BRIDGE_CURRENT_ADDRESS_SPEC > ; # [doc = ""]
pub mod bridge_current_address { # [doc = "Register `BRIDGE_CURRENT_ADDRESS` reader"]
pub type R = crate :: R < BRIDGE_CURRENT_ADDRESS_SPEC > ; # [doc = "Register `BRIDGE_CURRENT_ADDRESS` writer"]
pub type W = crate :: W < BRIDGE_CURRENT_ADDRESS_SPEC > ; # [doc = "Field `bridge_current_address` reader - "]
pub type BRIDGE_CURRENT_ADDRESS_R = crate :: FieldReader < u32 > ; # [doc = "Field `bridge_current_address` writer - "]
pub type BRIDGE_CURRENT_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn bridge_current_address (& self) -> BRIDGE_CURRENT_ADDRESS_R { BRIDGE_CURRENT_ADDRESS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn bridge_current_address (& mut self) -> BRIDGE_CURRENT_ADDRESS_W < BRIDGE_CURRENT_ADDRESS_SPEC , 0 > { BRIDGE_CURRENT_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`bridge_current_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`bridge_current_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BRIDGE_CURRENT_ADDRESS_SPEC ; impl crate :: RegisterSpec for BRIDGE_CURRENT_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`bridge_current_address::R`](R) reader structure"]
impl crate :: Readable for BRIDGE_CURRENT_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`bridge_current_address::W`](W) writer structure"]
impl crate :: Writable for BRIDGE_CURRENT_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BRIDGE_CURRENT_ADDRESS to value 0"]
impl crate :: Resettable for BRIDGE_CURRENT_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VSYNC_STATUS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_status`]
module"]
pub type VSYNC_STATUS = crate :: Reg < vsync_status :: VSYNC_STATUS_SPEC > ; # [doc = ""]
pub mod vsync_status { # [doc = "Register `VSYNC_STATUS` reader"]
pub type R = crate :: R < VSYNC_STATUS_SPEC > ; # [doc = "Register `VSYNC_STATUS` writer"]
pub type W = crate :: W < VSYNC_STATUS_SPEC > ; # [doc = "Field `vsync_status` reader - "]
pub type VSYNC_STATUS_R = crate :: BitReader ; # [doc = "Field `vsync_status` writer - "]
pub type VSYNC_STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn vsync_status (& self) -> VSYNC_STATUS_R { VSYNC_STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn vsync_status (& mut self) -> VSYNC_STATUS_W < VSYNC_STATUS_SPEC , 0 > { VSYNC_STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_STATUS_SPEC ; impl crate :: RegisterSpec for VSYNC_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_status::R`](R) reader structure"]
impl crate :: Readable for VSYNC_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_status::W`](W) writer structure"]
impl crate :: Writable for VSYNC_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_STATUS to value 0"]
impl crate :: Resettable for VSYNC_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VBLANK_STATUS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vblank_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vblank_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vblank_status`]
module"]
pub type VBLANK_STATUS = crate :: Reg < vblank_status :: VBLANK_STATUS_SPEC > ; # [doc = ""]
pub mod vblank_status { # [doc = "Register `VBLANK_STATUS` reader"]
pub type R = crate :: R < VBLANK_STATUS_SPEC > ; # [doc = "Register `VBLANK_STATUS` writer"]
pub type W = crate :: W < VBLANK_STATUS_SPEC > ; # [doc = "Field `vblank_status` reader - "]
pub type VBLANK_STATUS_R = crate :: BitReader ; # [doc = "Field `vblank_status` writer - "]
pub type VBLANK_STATUS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn vblank_status (& self) -> VBLANK_STATUS_R { VBLANK_STATUS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn vblank_status (& mut self) -> VBLANK_STATUS_W < VBLANK_STATUS_SPEC , 0 > { VBLANK_STATUS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vblank_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vblank_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VBLANK_STATUS_SPEC ; impl crate :: RegisterSpec for VBLANK_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vblank_status::R`](R) reader structure"]
impl crate :: Readable for VBLANK_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`vblank_status::W`](W) writer structure"]
impl crate :: Writable for VBLANK_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VBLANK_STATUS to value 0"]
impl crate :: Resettable for VBLANK_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FRAME_COUNTER (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`frame_counter::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`frame_counter::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`frame_counter`]
module"]
pub type FRAME_COUNTER = crate :: Reg < frame_counter :: FRAME_COUNTER_SPEC > ; # [doc = ""]
pub mod frame_counter { # [doc = "Register `FRAME_COUNTER` reader"]
pub type R = crate :: R < FRAME_COUNTER_SPEC > ; # [doc = "Register `FRAME_COUNTER` writer"]
pub type W = crate :: W < FRAME_COUNTER_SPEC > ; # [doc = "Field `frame_counter` reader - "]
pub type FRAME_COUNTER_R = crate :: FieldReader < u32 > ; # [doc = "Field `frame_counter` writer - "]
pub type FRAME_COUNTER_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn frame_counter (& self) -> FRAME_COUNTER_R { FRAME_COUNTER_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn frame_counter (& mut self) -> FRAME_COUNTER_W < FRAME_COUNTER_SPEC , 0 > { FRAME_COUNTER_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`frame_counter::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`frame_counter::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FRAME_COUNTER_SPEC ; impl crate :: RegisterSpec for FRAME_COUNTER_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`frame_counter::R`](R) reader structure"]
impl crate :: Readable for FRAME_COUNTER_SPEC { } # [doc = "`write(|w| ..)` method takes [`frame_counter::W`](W) writer structure"]
impl crate :: Writable for FRAME_COUNTER_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FRAME_COUNTER to value 0"]
impl crate :: Resettable for FRAME_COUNTER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AUDIO_OUT (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_out::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_out::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`audio_out`]
module"]
pub type AUDIO_OUT = crate :: Reg < audio_out :: AUDIO_OUT_SPEC > ; # [doc = ""]
pub mod audio_out { # [doc = "Register `AUDIO_OUT` reader"]
pub type R = crate :: R < AUDIO_OUT_SPEC > ; # [doc = "Register `AUDIO_OUT` writer"]
pub type W = crate :: W < AUDIO_OUT_SPEC > ; # [doc = "Field `audio_out` reader - "]
pub type AUDIO_OUT_R = crate :: FieldReader < u32 > ; # [doc = "Field `audio_out` writer - "]
pub type AUDIO_OUT_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn audio_out (& self) -> AUDIO_OUT_R { AUDIO_OUT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn audio_out (& mut self) -> AUDIO_OUT_W < AUDIO_OUT_SPEC , 0 > { AUDIO_OUT_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_out::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_out::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AUDIO_OUT_SPEC ; impl crate :: RegisterSpec for AUDIO_OUT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`audio_out::R`](R) reader structure"]
impl crate :: Readable for AUDIO_OUT_SPEC { } # [doc = "`write(|w| ..)` method takes [`audio_out::W`](W) writer structure"]
impl crate :: Writable for AUDIO_OUT_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AUDIO_OUT to value 0"]
impl crate :: Resettable for AUDIO_OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AUDIO_PLAYBACK_EN (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_playback_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_playback_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`audio_playback_en`]
module"]
pub type AUDIO_PLAYBACK_EN = crate :: Reg < audio_playback_en :: AUDIO_PLAYBACK_EN_SPEC > ; # [doc = ""]
pub mod audio_playback_en { # [doc = "Register `AUDIO_PLAYBACK_EN` reader"]
pub type R = crate :: R < AUDIO_PLAYBACK_EN_SPEC > ; # [doc = "Register `AUDIO_PLAYBACK_EN` writer"]
pub type W = crate :: W < AUDIO_PLAYBACK_EN_SPEC > ; # [doc = "Field `audio_playback_en` reader - "]
pub type AUDIO_PLAYBACK_EN_R = crate :: BitReader ; # [doc = "Field `audio_playback_en` writer - "]
pub type AUDIO_PLAYBACK_EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn audio_playback_en (& self) -> AUDIO_PLAYBACK_EN_R { AUDIO_PLAYBACK_EN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn audio_playback_en (& mut self) -> AUDIO_PLAYBACK_EN_W < AUDIO_PLAYBACK_EN_SPEC , 0 > { AUDIO_PLAYBACK_EN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_playback_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_playback_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AUDIO_PLAYBACK_EN_SPEC ; impl crate :: RegisterSpec for AUDIO_PLAYBACK_EN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`audio_playback_en::R`](R) reader structure"]
impl crate :: Readable for AUDIO_PLAYBACK_EN_SPEC { } # [doc = "`write(|w| ..)` method takes [`audio_playback_en::W`](W) writer structure"]
impl crate :: Writable for AUDIO_PLAYBACK_EN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AUDIO_PLAYBACK_EN to value 0"]
impl crate :: Resettable for AUDIO_PLAYBACK_EN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AUDIO_BUFFER_FLUSH (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_buffer_flush::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_buffer_flush::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`audio_buffer_flush`]
module"]
pub type AUDIO_BUFFER_FLUSH = crate :: Reg < audio_buffer_flush :: AUDIO_BUFFER_FLUSH_SPEC > ; # [doc = ""]
pub mod audio_buffer_flush { # [doc = "Register `AUDIO_BUFFER_FLUSH` reader"]
pub type R = crate :: R < AUDIO_BUFFER_FLUSH_SPEC > ; # [doc = "Register `AUDIO_BUFFER_FLUSH` writer"]
pub type W = crate :: W < AUDIO_BUFFER_FLUSH_SPEC > ; # [doc = "Field `audio_buffer_flush` reader - "]
pub type AUDIO_BUFFER_FLUSH_R = crate :: BitReader ; # [doc = "Field `audio_buffer_flush` writer - "]
pub type AUDIO_BUFFER_FLUSH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn audio_buffer_flush (& self) -> AUDIO_BUFFER_FLUSH_R { AUDIO_BUFFER_FLUSH_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn audio_buffer_flush (& mut self) -> AUDIO_BUFFER_FLUSH_W < AUDIO_BUFFER_FLUSH_SPEC , 0 > { AUDIO_BUFFER_FLUSH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_buffer_flush::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_buffer_flush::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AUDIO_BUFFER_FLUSH_SPEC ; impl crate :: RegisterSpec for AUDIO_BUFFER_FLUSH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`audio_buffer_flush::R`](R) reader structure"]
impl crate :: Readable for AUDIO_BUFFER_FLUSH_SPEC { } # [doc = "`write(|w| ..)` method takes [`audio_buffer_flush::W`](W) writer structure"]
impl crate :: Writable for AUDIO_BUFFER_FLUSH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AUDIO_BUFFER_FLUSH to value 0"]
impl crate :: Resettable for AUDIO_BUFFER_FLUSH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AUDIO_BUFFER_FILL (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_buffer_fill::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_buffer_fill::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`audio_buffer_fill`]
module"]
pub type AUDIO_BUFFER_FILL = crate :: Reg < audio_buffer_fill :: AUDIO_BUFFER_FILL_SPEC > ; # [doc = ""]
pub mod audio_buffer_fill { # [doc = "Register `AUDIO_BUFFER_FILL` reader"]
pub type R = crate :: R < AUDIO_BUFFER_FILL_SPEC > ; # [doc = "Register `AUDIO_BUFFER_FILL` writer"]
pub type W = crate :: W < AUDIO_BUFFER_FILL_SPEC > ; # [doc = "Field `audio_buffer_fill` reader - "]
pub type AUDIO_BUFFER_FILL_R = crate :: FieldReader < u16 > ; # [doc = "Field `audio_buffer_fill` writer - "]
pub type AUDIO_BUFFER_FILL_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn audio_buffer_fill (& self) -> AUDIO_BUFFER_FILL_R { AUDIO_BUFFER_FILL_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn audio_buffer_fill (& mut self) -> AUDIO_BUFFER_FILL_W < AUDIO_BUFFER_FILL_SPEC , 0 > { AUDIO_BUFFER_FILL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`audio_buffer_fill::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`audio_buffer_fill::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AUDIO_BUFFER_FILL_SPEC ; impl crate :: RegisterSpec for AUDIO_BUFFER_FILL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`audio_buffer_fill::R`](R) reader structure"]
impl crate :: Readable for AUDIO_BUFFER_FILL_SPEC { } # [doc = "`write(|w| ..)` method takes [`audio_buffer_fill::W`](W) writer structure"]
impl crate :: Writable for AUDIO_BUFFER_FILL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AUDIO_BUFFER_FILL to value 0"]
impl crate :: Resettable for AUDIO_BUFFER_FILL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RTC_UNIX_SECONDS (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_unix_seconds::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_unix_seconds::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rtc_unix_seconds`]
module"]
pub type RTC_UNIX_SECONDS = crate :: Reg < rtc_unix_seconds :: RTC_UNIX_SECONDS_SPEC > ; # [doc = ""]
pub mod rtc_unix_seconds { # [doc = "Register `RTC_UNIX_SECONDS` reader"]
pub type R = crate :: R < RTC_UNIX_SECONDS_SPEC > ; # [doc = "Register `RTC_UNIX_SECONDS` writer"]
pub type W = crate :: W < RTC_UNIX_SECONDS_SPEC > ; # [doc = "Field `rtc_unix_seconds` reader - "]
pub type RTC_UNIX_SECONDS_R = crate :: FieldReader < u32 > ; # [doc = "Field `rtc_unix_seconds` writer - "]
pub type RTC_UNIX_SECONDS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn rtc_unix_seconds (& self) -> RTC_UNIX_SECONDS_R { RTC_UNIX_SECONDS_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn rtc_unix_seconds (& mut self) -> RTC_UNIX_SECONDS_W < RTC_UNIX_SECONDS_SPEC , 0 > { RTC_UNIX_SECONDS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_unix_seconds::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_unix_seconds::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RTC_UNIX_SECONDS_SPEC ; impl crate :: RegisterSpec for RTC_UNIX_SECONDS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rtc_unix_seconds::R`](R) reader structure"]
impl crate :: Readable for RTC_UNIX_SECONDS_SPEC { } # [doc = "`write(|w| ..)` method takes [`rtc_unix_seconds::W`](W) writer structure"]
impl crate :: Writable for RTC_UNIX_SECONDS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RTC_UNIX_SECONDS to value 0"]
impl crate :: Resettable for RTC_UNIX_SECONDS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RTC_DATE_BCD (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_date_bcd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_date_bcd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rtc_date_bcd`]
module"]
pub type RTC_DATE_BCD = crate :: Reg < rtc_date_bcd :: RTC_DATE_BCD_SPEC > ; # [doc = ""]
pub mod rtc_date_bcd { # [doc = "Register `RTC_DATE_BCD` reader"]
pub type R = crate :: R < RTC_DATE_BCD_SPEC > ; # [doc = "Register `RTC_DATE_BCD` writer"]
pub type W = crate :: W < RTC_DATE_BCD_SPEC > ; # [doc = "Field `rtc_date_bcd` reader - "]
pub type RTC_DATE_BCD_R = crate :: FieldReader < u32 > ; # [doc = "Field `rtc_date_bcd` writer - "]
pub type RTC_DATE_BCD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn rtc_date_bcd (& self) -> RTC_DATE_BCD_R { RTC_DATE_BCD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn rtc_date_bcd (& mut self) -> RTC_DATE_BCD_W < RTC_DATE_BCD_SPEC , 0 > { RTC_DATE_BCD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_date_bcd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_date_bcd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RTC_DATE_BCD_SPEC ; impl crate :: RegisterSpec for RTC_DATE_BCD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rtc_date_bcd::R`](R) reader structure"]
impl crate :: Readable for RTC_DATE_BCD_SPEC { } # [doc = "`write(|w| ..)` method takes [`rtc_date_bcd::W`](W) writer structure"]
impl crate :: Writable for RTC_DATE_BCD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RTC_DATE_BCD to value 0"]
impl crate :: Resettable for RTC_DATE_BCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RTC_TIME_BCD (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_time_bcd::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_time_bcd::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rtc_time_bcd`]
module"]
pub type RTC_TIME_BCD = crate :: Reg < rtc_time_bcd :: RTC_TIME_BCD_SPEC > ; # [doc = ""]
pub mod rtc_time_bcd { # [doc = "Register `RTC_TIME_BCD` reader"]
pub type R = crate :: R < RTC_TIME_BCD_SPEC > ; # [doc = "Register `RTC_TIME_BCD` writer"]
pub type W = crate :: W < RTC_TIME_BCD_SPEC > ; # [doc = "Field `rtc_time_bcd` reader - "]
pub type RTC_TIME_BCD_R = crate :: FieldReader < u32 > ; # [doc = "Field `rtc_time_bcd` writer - "]
pub type RTC_TIME_BCD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn rtc_time_bcd (& self) -> RTC_TIME_BCD_R { RTC_TIME_BCD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn rtc_time_bcd (& mut self) -> RTC_TIME_BCD_W < RTC_TIME_BCD_SPEC , 0 > { RTC_TIME_BCD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rtc_time_bcd::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rtc_time_bcd::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RTC_TIME_BCD_SPEC ; impl crate :: RegisterSpec for RTC_TIME_BCD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rtc_time_bcd::R`](R) reader structure"]
impl crate :: Readable for RTC_TIME_BCD_SPEC { } # [doc = "`write(|w| ..)` method takes [`rtc_time_bcd::W`](W) writer structure"]
impl crate :: Writable for RTC_TIME_BCD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RTC_TIME_BCD to value 0"]
impl crate :: Resettable for RTC_TIME_BCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHIP_ID1 (rw) register accessor: Bits 32-63 of `MAIN_CHIP_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chip_id1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chip_id1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`chip_id1`]
module"]
pub type CHIP_ID1 = crate :: Reg < chip_id1 :: CHIP_ID1_SPEC > ; # [doc = "Bits 32-63 of `MAIN_CHIP_ID`."]
pub mod chip_id1 { # [doc = "Register `CHIP_ID1` reader"]
pub type R = crate :: R < CHIP_ID1_SPEC > ; # [doc = "Register `CHIP_ID1` writer"]
pub type W = crate :: W < CHIP_ID1_SPEC > ; # [doc = "Field `chip_id` reader - "]
pub type CHIP_ID_R = crate :: FieldReader < u32 > ; # [doc = "Field `chip_id` writer - "]
pub type CHIP_ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn chip_id (& self) -> CHIP_ID_R { CHIP_ID_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn chip_id (& mut self) -> CHIP_ID_W < CHIP_ID1_SPEC , 0 > { CHIP_ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 32-63 of `MAIN_CHIP_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chip_id1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chip_id1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CHIP_ID1_SPEC ; impl crate :: RegisterSpec for CHIP_ID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`chip_id1::R`](R) reader structure"]
impl crate :: Readable for CHIP_ID1_SPEC { } # [doc = "`write(|w| ..)` method takes [`chip_id1::W`](W) writer structure"]
impl crate :: Writable for CHIP_ID1_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHIP_ID1 to value 0"]
impl crate :: Resettable for CHIP_ID1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHIP_ID0 (rw) register accessor: Bits 0-31 of `MAIN_CHIP_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chip_id0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chip_id0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`chip_id0`]
module"]
pub type CHIP_ID0 = crate :: Reg < chip_id0 :: CHIP_ID0_SPEC > ; # [doc = "Bits 0-31 of `MAIN_CHIP_ID`."]
pub mod chip_id0 { # [doc = "Register `CHIP_ID0` reader"]
pub type R = crate :: R < CHIP_ID0_SPEC > ; # [doc = "Register `CHIP_ID0` writer"]
pub type W = crate :: W < CHIP_ID0_SPEC > ; # [doc = "Field `chip_id` reader - "]
pub type CHIP_ID_R = crate :: FieldReader < u32 > ; # [doc = "Field `chip_id` writer - "]
pub type CHIP_ID_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn chip_id (& self) -> CHIP_ID_R { CHIP_ID_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn chip_id (& mut self) -> CHIP_ID_W < CHIP_ID0_SPEC , 0 > { CHIP_ID_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 0-31 of `MAIN_CHIP_ID`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`chip_id0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`chip_id0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CHIP_ID0_SPEC ; impl crate :: RegisterSpec for CHIP_ID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`chip_id0::R`](R) reader structure"]
impl crate :: Readable for CHIP_ID0_SPEC { } # [doc = "`write(|w| ..)` method takes [`chip_id0::W`](W) writer structure"]
impl crate :: Writable for CHIP_ID0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHIP_ID0 to value 0"]
impl crate :: Resettable for CHIP_ID0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "SDRAM"]
pub struct SDRAM { _marker : PhantomData < * const () > } unsafe impl Send for SDRAM { } impl SDRAM { # [doc = r"Pointer to the register block"]
pub const PTR : * const sdram :: RegisterBlock = 0xf000_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sdram :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SDRAM { type Target = sdram :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SDRAM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SDRAM") . finish () } } # [doc = "SDRAM"]
pub mod sdram { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control DFI signals common to all phases"]
pub dfii_control : DFII_CONTROL , # [doc = "0x04 - Control DFI signals on a single phase"]
pub dfii_pi0_command : DFII_PI0_COMMAND , # [doc = "0x08 - "]
pub dfii_pi0_command_issue : DFII_PI0_COMMAND_ISSUE , # [doc = "0x0c - DFI address bus"]
pub dfii_pi0_address : DFII_PI0_ADDRESS , # [doc = "0x10 - DFI bank address bus"]
pub dfii_pi0_baddress : DFII_PI0_BADDRESS , # [doc = "0x14 - DFI write data bus"]
pub dfii_pi0_wrdata : DFII_PI0_WRDATA , # [doc = "0x18 - DFI read data bus"]
pub dfii_pi0_rddata : DFII_PI0_RDDATA , # [doc = "0x1c - Control DFI signals on a single phase"]
pub dfii_pi1_command : DFII_PI1_COMMAND , # [doc = "0x20 - "]
pub dfii_pi1_command_issue : DFII_PI1_COMMAND_ISSUE , # [doc = "0x24 - DFI address bus"]
pub dfii_pi1_address : DFII_PI1_ADDRESS , # [doc = "0x28 - DFI bank address bus"]
pub dfii_pi1_baddress : DFII_PI1_BADDRESS , # [doc = "0x2c - DFI write data bus"]
pub dfii_pi1_wrdata : DFII_PI1_WRDATA , # [doc = "0x30 - DFI read data bus"]
pub dfii_pi1_rddata : DFII_PI1_RDDATA , } # [doc = "DFII_CONTROL (rw) register accessor: Control DFI signals common to all phases\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_control::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_control::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_control`]
module"]
pub type DFII_CONTROL = crate :: Reg < dfii_control :: DFII_CONTROL_SPEC > ; # [doc = "Control DFI signals common to all phases"]
pub mod dfii_control { # [doc = "Register `DFII_CONTROL` reader"]
pub type R = crate :: R < DFII_CONTROL_SPEC > ; # [doc = "Register `DFII_CONTROL` writer"]
pub type W = crate :: W < DFII_CONTROL_SPEC > ; # [doc = "Field `sel` reader - None"]
pub type SEL_R = crate :: BitReader ; # [doc = "Field `sel` writer - None"]
pub type SEL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cke` reader - DFI clock enable bus"]
pub type CKE_R = crate :: BitReader ; # [doc = "Field `cke` writer - DFI clock enable bus"]
pub type CKE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `odt` reader - DFI on-die termination bus"]
pub type ODT_R = crate :: BitReader ; # [doc = "Field `odt` writer - DFI on-die termination bus"]
pub type ODT_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `reset_n` reader - DFI clock reset bus"]
pub type RESET_N_R = crate :: BitReader ; # [doc = "Field `reset_n` writer - DFI clock reset bus"]
pub type RESET_N_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - None"]
# [inline (always)]
pub fn sel (& self) -> SEL_R { SEL_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
pub fn cke (& self) -> CKE_R { CKE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
pub fn odt (& self) -> ODT_R { ODT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
pub fn reset_n (& self) -> RESET_N_R { RESET_N_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - None"]
# [inline (always)]
# [must_use]
pub fn sel (& mut self) -> SEL_W < DFII_CONTROL_SPEC , 0 > { SEL_W :: new (self) } # [doc = "Bit 1 - DFI clock enable bus"]
# [inline (always)]
# [must_use]
pub fn cke (& mut self) -> CKE_W < DFII_CONTROL_SPEC , 1 > { CKE_W :: new (self) } # [doc = "Bit 2 - DFI on-die termination bus"]
# [inline (always)]
# [must_use]
pub fn odt (& mut self) -> ODT_W < DFII_CONTROL_SPEC , 2 > { ODT_W :: new (self) } # [doc = "Bit 3 - DFI clock reset bus"]
# [inline (always)]
# [must_use]
pub fn reset_n (& mut self) -> RESET_N_W < DFII_CONTROL_SPEC , 3 > { RESET_N_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals common to all phases\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_control::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_control::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_CONTROL_SPEC ; impl crate :: RegisterSpec for DFII_CONTROL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_control::R`](R) reader structure"]
impl crate :: Readable for DFII_CONTROL_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_control::W`](W) writer structure"]
impl crate :: Writable for DFII_CONTROL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_CONTROL to value 0x01"]
impl crate :: Resettable for DFII_CONTROL_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "DFII_PI0_COMMAND (rw) register accessor: Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_command`]
module"]
pub type DFII_PI0_COMMAND = crate :: Reg < dfii_pi0_command :: DFII_PI0_COMMAND_SPEC > ; # [doc = "Control DFI signals on a single phase"]
pub mod dfii_pi0_command { # [doc = "Register `DFII_PI0_COMMAND` reader"]
pub type R = crate :: R < DFII_PI0_COMMAND_SPEC > ; # [doc = "Register `DFII_PI0_COMMAND` writer"]
pub type W = crate :: W < DFII_PI0_COMMAND_SPEC > ; # [doc = "Field `cs` reader - DFI chip select bus"]
pub type CS_R = crate :: BitReader ; # [doc = "Field `cs` writer - DFI chip select bus"]
pub type CS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `we` reader - DFI write enable bus"]
pub type WE_R = crate :: BitReader ; # [doc = "Field `we` writer - DFI write enable bus"]
pub type WE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cas` reader - DFI column address strobe bus"]
pub type CAS_R = crate :: BitReader ; # [doc = "Field `cas` writer - DFI column address strobe bus"]
pub type CAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `ras` reader - DFI row address strobe bus"]
pub type RAS_R = crate :: BitReader ; # [doc = "Field `ras` writer - DFI row address strobe bus"]
pub type RAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `wren` reader - DFI write data enable bus"]
pub type WREN_R = crate :: BitReader ; # [doc = "Field `wren` writer - DFI write data enable bus"]
pub type WREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rden` reader - DFI read data enable bus"]
pub type RDEN_R = crate :: BitReader ; # [doc = "Field `rden` writer - DFI read data enable bus"]
pub type RDEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_top` reader - DFI chip select bus for top half only"]
pub type CS_TOP_R = crate :: BitReader ; # [doc = "Field `cs_top` writer - DFI chip select bus for top half only"]
pub type CS_TOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_bottom` reader - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_R = crate :: BitReader ; # [doc = "Field `cs_bottom` writer - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
pub fn cs (& self) -> CS_R { CS_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
pub fn we (& self) -> WE_R { WE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
pub fn cas (& self) -> CAS_R { CAS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
pub fn ras (& self) -> RAS_R { RAS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
pub fn wren (& self) -> WREN_R { WREN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
pub fn rden (& self) -> RDEN_R { RDEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
pub fn cs_top (& self) -> CS_TOP_R { CS_TOP_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
pub fn cs_bottom (& self) -> CS_BOTTOM_R { CS_BOTTOM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
# [must_use]
pub fn cs (& mut self) -> CS_W < DFII_PI0_COMMAND_SPEC , 0 > { CS_W :: new (self) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
# [must_use]
pub fn we (& mut self) -> WE_W < DFII_PI0_COMMAND_SPEC , 1 > { WE_W :: new (self) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
# [must_use]
pub fn cas (& mut self) -> CAS_W < DFII_PI0_COMMAND_SPEC , 2 > { CAS_W :: new (self) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
# [must_use]
pub fn ras (& mut self) -> RAS_W < DFII_PI0_COMMAND_SPEC , 3 > { RAS_W :: new (self) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
# [must_use]
pub fn wren (& mut self) -> WREN_W < DFII_PI0_COMMAND_SPEC , 4 > { WREN_W :: new (self) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
# [must_use]
pub fn rden (& mut self) -> RDEN_W < DFII_PI0_COMMAND_SPEC , 5 > { RDEN_W :: new (self) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
# [must_use]
pub fn cs_top (& mut self) -> CS_TOP_W < DFII_PI0_COMMAND_SPEC , 6 > { CS_TOP_W :: new (self) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
# [must_use]
pub fn cs_bottom (& mut self) -> CS_BOTTOM_W < DFII_PI0_COMMAND_SPEC , 7 > { CS_BOTTOM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_COMMAND_SPEC ; impl crate :: RegisterSpec for DFII_PI0_COMMAND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_COMMAND_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_COMMAND_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND to value 0"]
impl crate :: Resettable for DFII_PI0_COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_COMMAND_ISSUE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command_issue::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_command_issue`]
module"]
pub type DFII_PI0_COMMAND_ISSUE = crate :: Reg < dfii_pi0_command_issue :: DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = ""]
pub mod dfii_pi0_command_issue { # [doc = "Register `DFII_PI0_COMMAND_ISSUE` reader"]
pub type R = crate :: R < DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = "Register `DFII_PI0_COMMAND_ISSUE` writer"]
pub type W = crate :: W < DFII_PI0_COMMAND_ISSUE_SPEC > ; # [doc = "Field `dfii_pi0_command_issue` reader - "]
pub type DFII_PI0_COMMAND_ISSUE_R = crate :: BitReader ; # [doc = "Field `dfii_pi0_command_issue` writer - "]
pub type DFII_PI0_COMMAND_ISSUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi0_command_issue (& self) -> DFII_PI0_COMMAND_ISSUE_R { DFII_PI0_COMMAND_ISSUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_command_issue (& mut self) -> DFII_PI0_COMMAND_ISSUE_W < DFII_PI0_COMMAND_ISSUE_SPEC , 0 > { DFII_PI0_COMMAND_ISSUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_command_issue::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_command_issue::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_COMMAND_ISSUE_SPEC ; impl crate :: RegisterSpec for DFII_PI0_COMMAND_ISSUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_command_issue::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_COMMAND_ISSUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_command_issue::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_COMMAND_ISSUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_COMMAND_ISSUE to value 0"]
impl crate :: Resettable for DFII_PI0_COMMAND_ISSUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_ADDRESS (rw) register accessor: DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_address`]
module"]
pub type DFII_PI0_ADDRESS = crate :: Reg < dfii_pi0_address :: DFII_PI0_ADDRESS_SPEC > ; # [doc = "DFI address bus"]
pub mod dfii_pi0_address { # [doc = "Register `DFII_PI0_ADDRESS` reader"]
pub type R = crate :: R < DFII_PI0_ADDRESS_SPEC > ; # [doc = "Register `DFII_PI0_ADDRESS` writer"]
pub type W = crate :: W < DFII_PI0_ADDRESS_SPEC > ; # [doc = "Field `dfii_pi0_address` reader - "]
pub type DFII_PI0_ADDRESS_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_address` writer - "]
pub type DFII_PI0_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 13 , O , u16 > ; impl R { # [doc = "Bits 0:12"]
# [inline (always)]
pub fn dfii_pi0_address (& self) -> DFII_PI0_ADDRESS_R { DFII_PI0_ADDRESS_R :: new ((self . bits & 0x1fff) as u16) } } impl W { # [doc = "Bits 0:12"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_address (& mut self) -> DFII_PI0_ADDRESS_W < DFII_PI0_ADDRESS_SPEC , 0 > { DFII_PI0_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_ADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI0_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_address::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_address::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_ADDRESS to value 0"]
impl crate :: Resettable for DFII_PI0_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_BADDRESS (rw) register accessor: DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_baddress::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_baddress`]
module"]
pub type DFII_PI0_BADDRESS = crate :: Reg < dfii_pi0_baddress :: DFII_PI0_BADDRESS_SPEC > ; # [doc = "DFI bank address bus"]
pub mod dfii_pi0_baddress { # [doc = "Register `DFII_PI0_BADDRESS` reader"]
pub type R = crate :: R < DFII_PI0_BADDRESS_SPEC > ; # [doc = "Register `DFII_PI0_BADDRESS` writer"]
pub type W = crate :: W < DFII_PI0_BADDRESS_SPEC > ; # [doc = "Field `dfii_pi0_baddress` reader - "]
pub type DFII_PI0_BADDRESS_R = crate :: FieldReader ; # [doc = "Field `dfii_pi0_baddress` writer - "]
pub type DFII_PI0_BADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O > ; impl R { # [doc = "Bits 0:1"]
# [inline (always)]
pub fn dfii_pi0_baddress (& self) -> DFII_PI0_BADDRESS_R { DFII_PI0_BADDRESS_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_baddress (& mut self) -> DFII_PI0_BADDRESS_W < DFII_PI0_BADDRESS_SPEC , 0 > { DFII_PI0_BADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_baddress::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_baddress::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_BADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI0_BADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_baddress::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_BADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_baddress::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_BADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_BADDRESS to value 0"]
impl crate :: Resettable for DFII_PI0_BADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_WRDATA (rw) register accessor: DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_wrdata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_wrdata`]
module"]
pub type DFII_PI0_WRDATA = crate :: Reg < dfii_pi0_wrdata :: DFII_PI0_WRDATA_SPEC > ; # [doc = "DFI write data bus"]
pub mod dfii_pi0_wrdata { # [doc = "Register `DFII_PI0_WRDATA` reader"]
pub type R = crate :: R < DFII_PI0_WRDATA_SPEC > ; # [doc = "Register `DFII_PI0_WRDATA` writer"]
pub type W = crate :: W < DFII_PI0_WRDATA_SPEC > ; # [doc = "Field `dfii_pi0_wrdata` reader - "]
pub type DFII_PI0_WRDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_wrdata` writer - "]
pub type DFII_PI0_WRDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi0_wrdata (& self) -> DFII_PI0_WRDATA_R { DFII_PI0_WRDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_wrdata (& mut self) -> DFII_PI0_WRDATA_W < DFII_PI0_WRDATA_SPEC , 0 > { DFII_PI0_WRDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_wrdata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_wrdata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_WRDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI0_WRDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_wrdata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_WRDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_wrdata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_WRDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_WRDATA to value 0"]
impl crate :: Resettable for DFII_PI0_WRDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI0_RDDATA (rw) register accessor: DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_rddata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi0_rddata`]
module"]
pub type DFII_PI0_RDDATA = crate :: Reg < dfii_pi0_rddata :: DFII_PI0_RDDATA_SPEC > ; # [doc = "DFI read data bus"]
pub mod dfii_pi0_rddata { # [doc = "Register `DFII_PI0_RDDATA` reader"]
pub type R = crate :: R < DFII_PI0_RDDATA_SPEC > ; # [doc = "Register `DFII_PI0_RDDATA` writer"]
pub type W = crate :: W < DFII_PI0_RDDATA_SPEC > ; # [doc = "Field `dfii_pi0_rddata` reader - "]
pub type DFII_PI0_RDDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi0_rddata` writer - "]
pub type DFII_PI0_RDDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi0_rddata (& self) -> DFII_PI0_RDDATA_R { DFII_PI0_RDDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi0_rddata (& mut self) -> DFII_PI0_RDDATA_W < DFII_PI0_RDDATA_SPEC , 0 > { DFII_PI0_RDDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi0_rddata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi0_rddata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI0_RDDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI0_RDDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi0_rddata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI0_RDDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi0_rddata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI0_RDDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI0_RDDATA to value 0"]
impl crate :: Resettable for DFII_PI0_RDDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_COMMAND (rw) register accessor: Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_command`]
module"]
pub type DFII_PI1_COMMAND = crate :: Reg < dfii_pi1_command :: DFII_PI1_COMMAND_SPEC > ; # [doc = "Control DFI signals on a single phase"]
pub mod dfii_pi1_command { # [doc = "Register `DFII_PI1_COMMAND` reader"]
pub type R = crate :: R < DFII_PI1_COMMAND_SPEC > ; # [doc = "Register `DFII_PI1_COMMAND` writer"]
pub type W = crate :: W < DFII_PI1_COMMAND_SPEC > ; # [doc = "Field `cs` reader - DFI chip select bus"]
pub type CS_R = crate :: BitReader ; # [doc = "Field `cs` writer - DFI chip select bus"]
pub type CS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `we` reader - DFI write enable bus"]
pub type WE_R = crate :: BitReader ; # [doc = "Field `we` writer - DFI write enable bus"]
pub type WE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cas` reader - DFI column address strobe bus"]
pub type CAS_R = crate :: BitReader ; # [doc = "Field `cas` writer - DFI column address strobe bus"]
pub type CAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `ras` reader - DFI row address strobe bus"]
pub type RAS_R = crate :: BitReader ; # [doc = "Field `ras` writer - DFI row address strobe bus"]
pub type RAS_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `wren` reader - DFI write data enable bus"]
pub type WREN_R = crate :: BitReader ; # [doc = "Field `wren` writer - DFI write data enable bus"]
pub type WREN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rden` reader - DFI read data enable bus"]
pub type RDEN_R = crate :: BitReader ; # [doc = "Field `rden` writer - DFI read data enable bus"]
pub type RDEN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_top` reader - DFI chip select bus for top half only"]
pub type CS_TOP_R = crate :: BitReader ; # [doc = "Field `cs_top` writer - DFI chip select bus for top half only"]
pub type CS_TOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `cs_bottom` reader - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_R = crate :: BitReader ; # [doc = "Field `cs_bottom` writer - DFI chip select bus for bottom half only"]
pub type CS_BOTTOM_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
pub fn cs (& self) -> CS_R { CS_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
pub fn we (& self) -> WE_R { WE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
pub fn cas (& self) -> CAS_R { CAS_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
pub fn ras (& self) -> RAS_R { RAS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
pub fn wren (& self) -> WREN_R { WREN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
pub fn rden (& self) -> RDEN_R { RDEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
pub fn cs_top (& self) -> CS_TOP_R { CS_TOP_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
pub fn cs_bottom (& self) -> CS_BOTTOM_R { CS_BOTTOM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DFI chip select bus"]
# [inline (always)]
# [must_use]
pub fn cs (& mut self) -> CS_W < DFII_PI1_COMMAND_SPEC , 0 > { CS_W :: new (self) } # [doc = "Bit 1 - DFI write enable bus"]
# [inline (always)]
# [must_use]
pub fn we (& mut self) -> WE_W < DFII_PI1_COMMAND_SPEC , 1 > { WE_W :: new (self) } # [doc = "Bit 2 - DFI column address strobe bus"]
# [inline (always)]
# [must_use]
pub fn cas (& mut self) -> CAS_W < DFII_PI1_COMMAND_SPEC , 2 > { CAS_W :: new (self) } # [doc = "Bit 3 - DFI row address strobe bus"]
# [inline (always)]
# [must_use]
pub fn ras (& mut self) -> RAS_W < DFII_PI1_COMMAND_SPEC , 3 > { RAS_W :: new (self) } # [doc = "Bit 4 - DFI write data enable bus"]
# [inline (always)]
# [must_use]
pub fn wren (& mut self) -> WREN_W < DFII_PI1_COMMAND_SPEC , 4 > { WREN_W :: new (self) } # [doc = "Bit 5 - DFI read data enable bus"]
# [inline (always)]
# [must_use]
pub fn rden (& mut self) -> RDEN_W < DFII_PI1_COMMAND_SPEC , 5 > { RDEN_W :: new (self) } # [doc = "Bit 6 - DFI chip select bus for top half only"]
# [inline (always)]
# [must_use]
pub fn cs_top (& mut self) -> CS_TOP_W < DFII_PI1_COMMAND_SPEC , 6 > { CS_TOP_W :: new (self) } # [doc = "Bit 7 - DFI chip select bus for bottom half only"]
# [inline (always)]
# [must_use]
pub fn cs_bottom (& mut self) -> CS_BOTTOM_W < DFII_PI1_COMMAND_SPEC , 7 > { CS_BOTTOM_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Control DFI signals on a single phase\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_COMMAND_SPEC ; impl crate :: RegisterSpec for DFII_PI1_COMMAND_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_command::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_COMMAND_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_command::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_COMMAND_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_COMMAND to value 0"]
impl crate :: Resettable for DFII_PI1_COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_COMMAND_ISSUE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command_issue::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command_issue::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_command_issue`]
module"]
pub type DFII_PI1_COMMAND_ISSUE = crate :: Reg < dfii_pi1_command_issue :: DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = ""]
pub mod dfii_pi1_command_issue { # [doc = "Register `DFII_PI1_COMMAND_ISSUE` reader"]
pub type R = crate :: R < DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = "Register `DFII_PI1_COMMAND_ISSUE` writer"]
pub type W = crate :: W < DFII_PI1_COMMAND_ISSUE_SPEC > ; # [doc = "Field `dfii_pi1_command_issue` reader - "]
pub type DFII_PI1_COMMAND_ISSUE_R = crate :: BitReader ; # [doc = "Field `dfii_pi1_command_issue` writer - "]
pub type DFII_PI1_COMMAND_ISSUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dfii_pi1_command_issue (& self) -> DFII_PI1_COMMAND_ISSUE_R { DFII_PI1_COMMAND_ISSUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_command_issue (& mut self) -> DFII_PI1_COMMAND_ISSUE_W < DFII_PI1_COMMAND_ISSUE_SPEC , 0 > { DFII_PI1_COMMAND_ISSUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_command_issue::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_command_issue::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_COMMAND_ISSUE_SPEC ; impl crate :: RegisterSpec for DFII_PI1_COMMAND_ISSUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_command_issue::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_COMMAND_ISSUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_command_issue::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_COMMAND_ISSUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_COMMAND_ISSUE to value 0"]
impl crate :: Resettable for DFII_PI1_COMMAND_ISSUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_ADDRESS (rw) register accessor: DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_address::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_address::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_address`]
module"]
pub type DFII_PI1_ADDRESS = crate :: Reg < dfii_pi1_address :: DFII_PI1_ADDRESS_SPEC > ; # [doc = "DFI address bus"]
pub mod dfii_pi1_address { # [doc = "Register `DFII_PI1_ADDRESS` reader"]
pub type R = crate :: R < DFII_PI1_ADDRESS_SPEC > ; # [doc = "Register `DFII_PI1_ADDRESS` writer"]
pub type W = crate :: W < DFII_PI1_ADDRESS_SPEC > ; # [doc = "Field `dfii_pi1_address` reader - "]
pub type DFII_PI1_ADDRESS_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_address` writer - "]
pub type DFII_PI1_ADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 13 , O , u16 > ; impl R { # [doc = "Bits 0:12"]
# [inline (always)]
pub fn dfii_pi1_address (& self) -> DFII_PI1_ADDRESS_R { DFII_PI1_ADDRESS_R :: new ((self . bits & 0x1fff) as u16) } } impl W { # [doc = "Bits 0:12"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_address (& mut self) -> DFII_PI1_ADDRESS_W < DFII_PI1_ADDRESS_SPEC , 0 > { DFII_PI1_ADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_address::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_address::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_ADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI1_ADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_address::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_ADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_address::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_ADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_ADDRESS to value 0"]
impl crate :: Resettable for DFII_PI1_ADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_BADDRESS (rw) register accessor: DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_baddress::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_baddress::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_baddress`]
module"]
pub type DFII_PI1_BADDRESS = crate :: Reg < dfii_pi1_baddress :: DFII_PI1_BADDRESS_SPEC > ; # [doc = "DFI bank address bus"]
pub mod dfii_pi1_baddress { # [doc = "Register `DFII_PI1_BADDRESS` reader"]
pub type R = crate :: R < DFII_PI1_BADDRESS_SPEC > ; # [doc = "Register `DFII_PI1_BADDRESS` writer"]
pub type W = crate :: W < DFII_PI1_BADDRESS_SPEC > ; # [doc = "Field `dfii_pi1_baddress` reader - "]
pub type DFII_PI1_BADDRESS_R = crate :: FieldReader ; # [doc = "Field `dfii_pi1_baddress` writer - "]
pub type DFII_PI1_BADDRESS_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 2 , O > ; impl R { # [doc = "Bits 0:1"]
# [inline (always)]
pub fn dfii_pi1_baddress (& self) -> DFII_PI1_BADDRESS_R { DFII_PI1_BADDRESS_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_baddress (& mut self) -> DFII_PI1_BADDRESS_W < DFII_PI1_BADDRESS_SPEC , 0 > { DFII_PI1_BADDRESS_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI bank address bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_baddress::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_baddress::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_BADDRESS_SPEC ; impl crate :: RegisterSpec for DFII_PI1_BADDRESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_baddress::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_BADDRESS_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_baddress::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_BADDRESS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_BADDRESS to value 0"]
impl crate :: Resettable for DFII_PI1_BADDRESS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_WRDATA (rw) register accessor: DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_wrdata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_wrdata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_wrdata`]
module"]
pub type DFII_PI1_WRDATA = crate :: Reg < dfii_pi1_wrdata :: DFII_PI1_WRDATA_SPEC > ; # [doc = "DFI write data bus"]
pub mod dfii_pi1_wrdata { # [doc = "Register `DFII_PI1_WRDATA` reader"]
pub type R = crate :: R < DFII_PI1_WRDATA_SPEC > ; # [doc = "Register `DFII_PI1_WRDATA` writer"]
pub type W = crate :: W < DFII_PI1_WRDATA_SPEC > ; # [doc = "Field `dfii_pi1_wrdata` reader - "]
pub type DFII_PI1_WRDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_wrdata` writer - "]
pub type DFII_PI1_WRDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi1_wrdata (& self) -> DFII_PI1_WRDATA_R { DFII_PI1_WRDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_wrdata (& mut self) -> DFII_PI1_WRDATA_W < DFII_PI1_WRDATA_SPEC , 0 > { DFII_PI1_WRDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI write data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_wrdata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_wrdata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_WRDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI1_WRDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_wrdata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_WRDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_wrdata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_WRDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_WRDATA to value 0"]
impl crate :: Resettable for DFII_PI1_WRDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFII_PI1_RDDATA (rw) register accessor: DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_rddata::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_rddata::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dfii_pi1_rddata`]
module"]
pub type DFII_PI1_RDDATA = crate :: Reg < dfii_pi1_rddata :: DFII_PI1_RDDATA_SPEC > ; # [doc = "DFI read data bus"]
pub mod dfii_pi1_rddata { # [doc = "Register `DFII_PI1_RDDATA` reader"]
pub type R = crate :: R < DFII_PI1_RDDATA_SPEC > ; # [doc = "Register `DFII_PI1_RDDATA` writer"]
pub type W = crate :: W < DFII_PI1_RDDATA_SPEC > ; # [doc = "Field `dfii_pi1_rddata` reader - "]
pub type DFII_PI1_RDDATA_R = crate :: FieldReader < u16 > ; # [doc = "Field `dfii_pi1_rddata` writer - "]
pub type DFII_PI1_RDDATA_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 16 , O , u16 > ; impl R { # [doc = "Bits 0:15"]
# [inline (always)]
pub fn dfii_pi1_rddata (& self) -> DFII_PI1_RDDATA_R { DFII_PI1_RDDATA_R :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15"]
# [inline (always)]
# [must_use]
pub fn dfii_pi1_rddata (& mut self) -> DFII_PI1_RDDATA_W < DFII_PI1_RDDATA_SPEC , 0 > { DFII_PI1_RDDATA_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "DFI read data bus\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dfii_pi1_rddata::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dfii_pi1_rddata::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DFII_PI1_RDDATA_SPEC ; impl crate :: RegisterSpec for DFII_PI1_RDDATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dfii_pi1_rddata::R`](R) reader structure"]
impl crate :: Readable for DFII_PI1_RDDATA_SPEC { } # [doc = "`write(|w| ..)` method takes [`dfii_pi1_rddata::W`](W) writer structure"]
impl crate :: Writable for DFII_PI1_RDDATA_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFII_PI1_RDDATA to value 0"]
impl crate :: Resettable for DFII_PI1_RDDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "TIMER0"]
pub struct TIMER0 { _marker : PhantomData < * const () > } unsafe impl Send for TIMER0 { } impl TIMER0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer0 :: RegisterBlock = 0xf000_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for TIMER0 { type Target = timer0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TIMER0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TIMER0") . finish () } } # [doc = "TIMER0"]
pub mod timer0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
pub load : LOAD , # [doc = "0x04 - Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
pub reload : RELOAD , # [doc = "0x08 - Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
pub en : EN , # [doc = "0x0c - Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
pub update_value : UPDATE_VALUE , # [doc = "0x10 - Latched countdown value. This value is updated by writing to ``update_value``."]
pub value : VALUE , # [doc = "0x14 - This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
pub ev_status : EV_STATUS , # [doc = "0x18 - When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub ev_pending : EV_PENDING , # [doc = "0x1c - This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
pub ev_enable : EV_ENABLE , # [doc = "0x20 - Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register."]
pub uptime_latch : UPTIME_LATCH , # [doc = "0x24 - Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles)."]
pub uptime_cycles1 : UPTIME_CYCLES1 , # [doc = "0x28 - Bits 0-31 of `TIMER0_UPTIME_CYCLES`."]
pub uptime_cycles0 : UPTIME_CYCLES0 , } # [doc = "LOAD (rw) register accessor: Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`load`]
module"]
pub type LOAD = crate :: Reg < load :: LOAD_SPEC > ; # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles."]
pub mod load { # [doc = "Register `LOAD` reader"]
pub type R = crate :: R < LOAD_SPEC > ; # [doc = "Register `LOAD` writer"]
pub type W = crate :: W < LOAD_SPEC > ; # [doc = "Field `load` reader - "]
pub type LOAD_R = crate :: FieldReader < u32 > ; # [doc = "Field `load` writer - "]
pub type LOAD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn load (& self) -> LOAD_R { LOAD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn load (& mut self) -> LOAD_W < LOAD_SPEC , 0 > { LOAD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`load::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`load::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LOAD_SPEC ; impl crate :: RegisterSpec for LOAD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`load::R`](R) reader structure"]
impl crate :: Readable for LOAD_SPEC { } # [doc = "`write(|w| ..)` method takes [`load::W`](W) writer structure"]
impl crate :: Writable for LOAD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOAD to value 0"]
impl crate :: Resettable for LOAD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RELOAD (rw) register accessor: Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`reload`]
module"]
pub type RELOAD = crate :: Reg < reload :: RELOAD_SPEC > ; # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles."]
pub mod reload { # [doc = "Register `RELOAD` reader"]
pub type R = crate :: R < RELOAD_SPEC > ; # [doc = "Register `RELOAD` writer"]
pub type W = crate :: W < RELOAD_SPEC > ; # [doc = "Field `reload` reader - "]
pub type RELOAD_R = crate :: FieldReader < u32 > ; # [doc = "Field `reload` writer - "]
pub type RELOAD_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn reload (& self) -> RELOAD_R { RELOAD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn reload (& mut self) -> RELOAD_W < RELOAD_SPEC , 0 > { RELOAD_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`reload::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`reload::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RELOAD_SPEC ; impl crate :: RegisterSpec for RELOAD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`reload::R`](R) reader structure"]
impl crate :: Readable for RELOAD_SPEC { } # [doc = "`write(|w| ..)` method takes [`reload::W`](W) writer structure"]
impl crate :: Writable for RELOAD_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RELOAD to value 0"]
impl crate :: Resettable for RELOAD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EN (rw) register accessor: Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`en`]
module"]
pub type EN = crate :: Reg < en :: EN_SPEC > ; # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer."]
pub mod en { # [doc = "Register `EN` reader"]
pub type R = crate :: R < EN_SPEC > ; # [doc = "Register `EN` writer"]
pub type W = crate :: W < EN_SPEC > ; # [doc = "Field `en` reader - "]
pub type EN_R = crate :: BitReader ; # [doc = "Field `en` writer - "]
pub type EN_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn en (& self) -> EN_R { EN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn en (& mut self) -> EN_W < EN_SPEC , 0 > { EN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EN_SPEC ; impl crate :: RegisterSpec for EN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`en::R`](R) reader structure"]
impl crate :: Readable for EN_SPEC { } # [doc = "`write(|w| ..)` method takes [`en::W`](W) writer structure"]
impl crate :: Writable for EN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EN to value 0"]
impl crate :: Resettable for EN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPDATE_VALUE (rw) register accessor: Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`update_value`]
module"]
pub type UPDATE_VALUE = crate :: Reg < update_value :: UPDATE_VALUE_SPEC > ; # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register."]
pub mod update_value { # [doc = "Register `UPDATE_VALUE` reader"]
pub type R = crate :: R < UPDATE_VALUE_SPEC > ; # [doc = "Register `UPDATE_VALUE` writer"]
pub type W = crate :: W < UPDATE_VALUE_SPEC > ; # [doc = "Field `update_value` reader - "]
pub type UPDATE_VALUE_R = crate :: BitReader ; # [doc = "Field `update_value` writer - "]
pub type UPDATE_VALUE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn update_value (& self) -> UPDATE_VALUE_R { UPDATE_VALUE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn update_value (& mut self) -> UPDATE_VALUE_W < UPDATE_VALUE_SPEC , 0 > { UPDATE_VALUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`update_value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`update_value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPDATE_VALUE_SPEC ; impl crate :: RegisterSpec for UPDATE_VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`update_value::R`](R) reader structure"]
impl crate :: Readable for UPDATE_VALUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`update_value::W`](W) writer structure"]
impl crate :: Writable for UPDATE_VALUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPDATE_VALUE to value 0"]
impl crate :: Resettable for UPDATE_VALUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VALUE (rw) register accessor: Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`value`]
module"]
pub type VALUE = crate :: Reg < value :: VALUE_SPEC > ; # [doc = "Latched countdown value. This value is updated by writing to ``update_value``."]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < VALUE_SPEC > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < VALUE_SPEC > ; # [doc = "Field `value` reader - "]
pub type VALUE_R = crate :: FieldReader < u32 > ; # [doc = "Field `value` writer - "]
pub type VALUE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn value (& mut self) -> VALUE_W < VALUE_SPEC , 0 > { VALUE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Latched countdown value. This value is updated by writing to ``update_value``.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`value::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VALUE_SPEC ; impl crate :: RegisterSpec for VALUE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for VALUE_SPEC { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for VALUE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for VALUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_status`]
module"]
pub type EV_STATUS = crate :: Reg < ev_status :: EV_STATUS_SPEC > ; # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EV_STATUS_SPEC > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EV_STATUS_SPEC > ; # [doc = "Field `zero` reader - Level of the ``zero`` event"]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - Level of the ``zero`` event"]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``zero`` event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_STATUS_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register contains the current raw level of the zero event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_STATUS_SPEC ; impl crate :: RegisterSpec for EV_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EV_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EV_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EV_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_pending`]
module"]
pub type EV_PENDING = crate :: Reg < ev_pending :: EV_PENDING_SPEC > ; # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EV_PENDING_SPEC > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EV_PENDING_SPEC > ; # [doc = "Field `zero` reader - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `zero` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_PENDING_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "When a zero event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_PENDING_SPEC ; impl crate :: RegisterSpec for EV_PENDING_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EV_PENDING_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EV_PENDING_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EV_PENDING_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_enable`]
module"]
pub type EV_ENABLE = crate :: Reg < ev_enable :: EV_ENABLE_SPEC > ; # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EV_ENABLE_SPEC > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EV_ENABLE_SPEC > ; # [doc = "Field `zero` reader - Write a ``1`` to enable the ``zero`` Event"]
pub type ZERO_R = crate :: BitReader ; # [doc = "Field `zero` writer - Write a ``1`` to enable the ``zero`` Event"]
pub type ZERO_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
pub fn zero (& self) -> ZERO_R { ZERO_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``zero`` Event"]
# [inline (always)]
# [must_use]
pub fn zero (& mut self) -> ZERO_W < EV_ENABLE_SPEC , 0 > { ZERO_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register enables the corresponding zero events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_ENABLE_SPEC ; impl crate :: RegisterSpec for EV_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EV_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EV_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EV_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_LATCH (rw) register accessor: Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_latch::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_latch::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_latch`]
module"]
pub type UPTIME_LATCH = crate :: Reg < uptime_latch :: UPTIME_LATCH_SPEC > ; # [doc = "Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register."]
pub mod uptime_latch { # [doc = "Register `UPTIME_LATCH` reader"]
pub type R = crate :: R < UPTIME_LATCH_SPEC > ; # [doc = "Register `UPTIME_LATCH` writer"]
pub type W = crate :: W < UPTIME_LATCH_SPEC > ; # [doc = "Field `uptime_latch` reader - "]
pub type UPTIME_LATCH_R = crate :: BitReader ; # [doc = "Field `uptime_latch` writer - "]
pub type UPTIME_LATCH_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn uptime_latch (& self) -> UPTIME_LATCH_R { UPTIME_LATCH_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn uptime_latch (& mut self) -> UPTIME_LATCH_W < UPTIME_LATCH_SPEC , 0 > { UPTIME_LATCH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Write a ``1`` to latch current Uptime cycles to ``uptime_cycles`` register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_latch::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_latch::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_LATCH_SPEC ; impl crate :: RegisterSpec for UPTIME_LATCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_latch::R`](R) reader structure"]
impl crate :: Readable for UPTIME_LATCH_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_latch::W`](W) writer structure"]
impl crate :: Writable for UPTIME_LATCH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_LATCH to value 0"]
impl crate :: Resettable for UPTIME_LATCH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_CYCLES1 (rw) register accessor: Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_cycles1`]
module"]
pub type UPTIME_CYCLES1 = crate :: Reg < uptime_cycles1 :: UPTIME_CYCLES1_SPEC > ; # [doc = "Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles)."]
pub mod uptime_cycles1 { # [doc = "Register `UPTIME_CYCLES1` reader"]
pub type R = crate :: R < UPTIME_CYCLES1_SPEC > ; # [doc = "Register `UPTIME_CYCLES1` writer"]
pub type W = crate :: W < UPTIME_CYCLES1_SPEC > ; # [doc = "Field `uptime_cycles` reader - "]
pub type UPTIME_CYCLES_R = crate :: FieldReader < u32 > ; # [doc = "Field `uptime_cycles` writer - "]
pub type UPTIME_CYCLES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn uptime_cycles (& self) -> UPTIME_CYCLES_R { UPTIME_CYCLES_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn uptime_cycles (& mut self) -> UPTIME_CYCLES_W < UPTIME_CYCLES1_SPEC , 0 > { UPTIME_CYCLES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 32-63 of `TIMER0_UPTIME_CYCLES`. Latched Uptime since power-up (in ``sys_clk`` cycles).\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_CYCLES1_SPEC ; impl crate :: RegisterSpec for UPTIME_CYCLES1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_cycles1::R`](R) reader structure"]
impl crate :: Readable for UPTIME_CYCLES1_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_cycles1::W`](W) writer structure"]
impl crate :: Writable for UPTIME_CYCLES1_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_CYCLES1 to value 0"]
impl crate :: Resettable for UPTIME_CYCLES1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UPTIME_CYCLES0 (rw) register accessor: Bits 0-31 of `TIMER0_UPTIME_CYCLES`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`uptime_cycles0`]
module"]
pub type UPTIME_CYCLES0 = crate :: Reg < uptime_cycles0 :: UPTIME_CYCLES0_SPEC > ; # [doc = "Bits 0-31 of `TIMER0_UPTIME_CYCLES`."]
pub mod uptime_cycles0 { # [doc = "Register `UPTIME_CYCLES0` reader"]
pub type R = crate :: R < UPTIME_CYCLES0_SPEC > ; # [doc = "Register `UPTIME_CYCLES0` writer"]
pub type W = crate :: W < UPTIME_CYCLES0_SPEC > ; # [doc = "Field `uptime_cycles` reader - "]
pub type UPTIME_CYCLES_R = crate :: FieldReader < u32 > ; # [doc = "Field `uptime_cycles` writer - "]
pub type UPTIME_CYCLES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn uptime_cycles (& self) -> UPTIME_CYCLES_R { UPTIME_CYCLES_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn uptime_cycles (& mut self) -> UPTIME_CYCLES_W < UPTIME_CYCLES0_SPEC , 0 > { UPTIME_CYCLES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "Bits 0-31 of `TIMER0_UPTIME_CYCLES`.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`uptime_cycles0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uptime_cycles0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct UPTIME_CYCLES0_SPEC ; impl crate :: RegisterSpec for UPTIME_CYCLES0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`uptime_cycles0::R`](R) reader structure"]
impl crate :: Readable for UPTIME_CYCLES0_SPEC { } # [doc = "`write(|w| ..)` method takes [`uptime_cycles0::W`](W) writer structure"]
impl crate :: Writable for UPTIME_CYCLES0_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UPTIME_CYCLES0 to value 0"]
impl crate :: Resettable for UPTIME_CYCLES0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "UART"]
pub struct UART { _marker : PhantomData < * const () > } unsafe impl Send for UART { } impl UART { # [doc = r"Pointer to the register block"]
pub const PTR : * const uart :: RegisterBlock = 0xf000_2800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const uart :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for UART { type Target = uart :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UART { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART") . finish () } } # [doc = "UART"]
pub mod uart { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub rxtx : RXTX , # [doc = "0x04 - TX FIFO Full."]
pub txfull : TXFULL , # [doc = "0x08 - RX FIFO Empty."]
pub rxempty : RXEMPTY , # [doc = "0x0c - This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
pub ev_status : EV_STATUS , # [doc = "0x10 - When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub ev_pending : EV_PENDING , # [doc = "0x14 - This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
pub ev_enable : EV_ENABLE , # [doc = "0x18 - TX FIFO Empty."]
pub txempty : TXEMPTY , # [doc = "0x1c - RX FIFO Full."]
pub rxfull : RXFULL , } # [doc = "RXTX (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxtx`]
module"]
pub type RXTX = crate :: Reg < rxtx :: RXTX_SPEC > ; # [doc = ""]
pub mod rxtx { # [doc = "Register `RXTX` reader"]
pub type R = crate :: R < RXTX_SPEC > ; # [doc = "Register `RXTX` writer"]
pub type W = crate :: W < RXTX_SPEC > ; # [doc = "Field `rxtx` reader - "]
pub type RXTX_R = crate :: FieldReader ; # [doc = "Field `rxtx` writer - "]
pub type RXTX_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 8 , O > ; impl R { # [doc = "Bits 0:7"]
# [inline (always)]
pub fn rxtx (& self) -> RXTX_R { RXTX_R :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7"]
# [inline (always)]
# [must_use]
pub fn rxtx (& mut self) -> RXTX_W < RXTX_SPEC , 0 > { RXTX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxtx::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxtx::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXTX_SPEC ; impl crate :: RegisterSpec for RXTX_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxtx::R`](R) reader structure"]
impl crate :: Readable for RXTX_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxtx::W`](W) writer structure"]
impl crate :: Writable for RXTX_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXTX to value 0"]
impl crate :: Resettable for RXTX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXFULL (rw) register accessor: TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`txfull`]
module"]
pub type TXFULL = crate :: Reg < txfull :: TXFULL_SPEC > ; # [doc = "TX FIFO Full."]
pub mod txfull { # [doc = "Register `TXFULL` reader"]
pub type R = crate :: R < TXFULL_SPEC > ; # [doc = "Register `TXFULL` writer"]
pub type W = crate :: W < TXFULL_SPEC > ; # [doc = "Field `txfull` reader - "]
pub type TXFULL_R = crate :: BitReader ; # [doc = "Field `txfull` writer - "]
pub type TXFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txfull (& self) -> TXFULL_R { TXFULL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txfull (& mut self) -> TXFULL_W < TXFULL_SPEC , 0 > { TXFULL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "TX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXFULL_SPEC ; impl crate :: RegisterSpec for TXFULL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`txfull::R`](R) reader structure"]
impl crate :: Readable for TXFULL_SPEC { } # [doc = "`write(|w| ..)` method takes [`txfull::W`](W) writer structure"]
impl crate :: Writable for TXFULL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXFULL to value 0"]
impl crate :: Resettable for TXFULL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXEMPTY (rw) register accessor: RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxempty`]
module"]
pub type RXEMPTY = crate :: Reg < rxempty :: RXEMPTY_SPEC > ; # [doc = "RX FIFO Empty."]
pub mod rxempty { # [doc = "Register `RXEMPTY` reader"]
pub type R = crate :: R < RXEMPTY_SPEC > ; # [doc = "Register `RXEMPTY` writer"]
pub type W = crate :: W < RXEMPTY_SPEC > ; # [doc = "Field `rxempty` reader - "]
pub type RXEMPTY_R = crate :: BitReader ; # [doc = "Field `rxempty` writer - "]
pub type RXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxempty (& self) -> RXEMPTY_R { RXEMPTY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxempty (& mut self) -> RXEMPTY_W < RXEMPTY_SPEC , 0 > { RXEMPTY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "RX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXEMPTY_SPEC ; impl crate :: RegisterSpec for RXEMPTY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxempty::R`](R) reader structure"]
impl crate :: Readable for RXEMPTY_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxempty::W`](W) writer structure"]
impl crate :: Writable for RXEMPTY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXEMPTY to value 0"]
impl crate :: Resettable for RXEMPTY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_STATUS (rw) register accessor: This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_status`]
module"]
pub type EV_STATUS = crate :: Reg < ev_status :: EV_STATUS_SPEC > ; # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect."]
pub mod ev_status { # [doc = "Register `EV_STATUS` reader"]
pub type R = crate :: R < EV_STATUS_SPEC > ; # [doc = "Register `EV_STATUS` writer"]
pub type W = crate :: W < EV_STATUS_SPEC > ; # [doc = "Field `tx` reader - Level of the ``tx`` event"]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - Level of the ``tx`` event"]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - Level of the ``rx`` event"]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - Level of the ``rx`` event"]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Level of the ``tx`` event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_STATUS_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - Level of the ``rx`` event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_STATUS_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register contains the current raw level of the rx event trigger. Writes to this register have no effect.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_status::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_status::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_STATUS_SPEC ; impl crate :: RegisterSpec for EV_STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_status::R`](R) reader structure"]
impl crate :: Readable for EV_STATUS_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_status::W`](W) writer structure"]
impl crate :: Writable for EV_STATUS_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_STATUS to value 0"]
impl crate :: Resettable for EV_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_PENDING (rw) register accessor: When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_pending`]
module"]
pub type EV_PENDING = crate :: Reg < ev_pending :: EV_PENDING_SPEC > ; # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register."]
pub mod ev_pending { # [doc = "Register `EV_PENDING` reader"]
pub type R = crate :: R < EV_PENDING_SPEC > ; # [doc = "Register `EV_PENDING` writer"]
pub type W = crate :: W < EV_PENDING_SPEC > ; # [doc = "Field `tx` reader - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - `1` if a `tx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_PENDING_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - `1` if a `rx` event occurred. This Event is triggered on a **falling** edge."]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_PENDING_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "When a rx event occurs, the corresponding bit will be set in this register. To clear the Event, set the corresponding bit in this register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_pending::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_pending::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_PENDING_SPEC ; impl crate :: RegisterSpec for EV_PENDING_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_pending::R`](R) reader structure"]
impl crate :: Readable for EV_PENDING_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_pending::W`](W) writer structure"]
impl crate :: Writable for EV_PENDING_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_PENDING to value 0"]
impl crate :: Resettable for EV_PENDING_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EV_ENABLE (rw) register accessor: This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`ev_enable`]
module"]
pub type EV_ENABLE = crate :: Reg < ev_enable :: EV_ENABLE_SPEC > ; # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events."]
pub mod ev_enable { # [doc = "Register `EV_ENABLE` reader"]
pub type R = crate :: R < EV_ENABLE_SPEC > ; # [doc = "Register `EV_ENABLE` writer"]
pub type W = crate :: W < EV_ENABLE_SPEC > ; # [doc = "Field `tx` reader - Write a ``1`` to enable the ``tx`` Event"]
pub type TX_R = crate :: BitReader ; # [doc = "Field `tx` writer - Write a ``1`` to enable the ``tx`` Event"]
pub type TX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; # [doc = "Field `rx` reader - Write a ``1`` to enable the ``rx`` Event"]
pub type RX_R = crate :: BitReader ; # [doc = "Field `rx` writer - Write a ``1`` to enable the ``rx`` Event"]
pub type RX_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
pub fn tx (& self) -> TX_R { TX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
pub fn rx (& self) -> RX_R { RX_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Write a ``1`` to enable the ``tx`` Event"]
# [inline (always)]
# [must_use]
pub fn tx (& mut self) -> TX_W < EV_ENABLE_SPEC , 0 > { TX_W :: new (self) } # [doc = "Bit 1 - Write a ``1`` to enable the ``rx`` Event"]
# [inline (always)]
# [must_use]
pub fn rx (& mut self) -> RX_W < EV_ENABLE_SPEC , 1 > { RX_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "This register enables the corresponding rx events. Write a ``0`` to this register to disable individual events.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ev_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ev_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EV_ENABLE_SPEC ; impl crate :: RegisterSpec for EV_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`ev_enable::R`](R) reader structure"]
impl crate :: Readable for EV_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`ev_enable::W`](W) writer structure"]
impl crate :: Writable for EV_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EV_ENABLE to value 0"]
impl crate :: Resettable for EV_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXEMPTY (rw) register accessor: TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`txempty`]
module"]
pub type TXEMPTY = crate :: Reg < txempty :: TXEMPTY_SPEC > ; # [doc = "TX FIFO Empty."]
pub mod txempty { # [doc = "Register `TXEMPTY` reader"]
pub type R = crate :: R < TXEMPTY_SPEC > ; # [doc = "Register `TXEMPTY` writer"]
pub type W = crate :: W < TXEMPTY_SPEC > ; # [doc = "Field `txempty` reader - "]
pub type TXEMPTY_R = crate :: BitReader ; # [doc = "Field `txempty` writer - "]
pub type TXEMPTY_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn txempty (& self) -> TXEMPTY_R { TXEMPTY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn txempty (& mut self) -> TXEMPTY_W < TXEMPTY_SPEC , 0 > { TXEMPTY_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "TX FIFO Empty.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txempty::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txempty::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TXEMPTY_SPEC ; impl crate :: RegisterSpec for TXEMPTY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`txempty::R`](R) reader structure"]
impl crate :: Readable for TXEMPTY_SPEC { } # [doc = "`write(|w| ..)` method takes [`txempty::W`](W) writer structure"]
impl crate :: Writable for TXEMPTY_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXEMPTY to value 0"]
impl crate :: Resettable for TXEMPTY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXFULL (rw) register accessor: RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`rxfull`]
module"]
pub type RXFULL = crate :: Reg < rxfull :: RXFULL_SPEC > ; # [doc = "RX FIFO Full."]
pub mod rxfull { # [doc = "Register `RXFULL` reader"]
pub type R = crate :: R < RXFULL_SPEC > ; # [doc = "Register `RXFULL` writer"]
pub type W = crate :: W < RXFULL_SPEC > ; # [doc = "Field `rxfull` reader - "]
pub type RXFULL_R = crate :: BitReader ; # [doc = "Field `rxfull` writer - "]
pub type RXFULL_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn rxfull (& self) -> RXFULL_R { RXFULL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn rxfull (& mut self) -> RXFULL_W < RXFULL_SPEC , 0 > { RXFULL_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "RX FIFO Full.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rxfull::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rxfull::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RXFULL_SPEC ; impl crate :: RegisterSpec for RXFULL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`rxfull::R`](R) reader structure"]
impl crate :: Readable for RXFULL_SPEC { } # [doc = "`write(|w| ..)` method takes [`rxfull::W`](W) writer structure"]
impl crate :: Writable for RXFULL_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXFULL to value 0"]
impl crate :: Resettable for RXFULL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "VIDEO_FRAMEBUFFER"]
pub struct VIDEO_FRAMEBUFFER { _marker : PhantomData < * const () > } unsafe impl Send for VIDEO_FRAMEBUFFER { } impl VIDEO_FRAMEBUFFER { # [doc = r"Pointer to the register block"]
pub const PTR : * const video_framebuffer :: RegisterBlock = 0xf000_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const video_framebuffer :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for VIDEO_FRAMEBUFFER { type Target = video_framebuffer :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VIDEO_FRAMEBUFFER { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VIDEO_FRAMEBUFFER") . finish () } } # [doc = "VIDEO_FRAMEBUFFER"]
pub mod video_framebuffer { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub dma_base : DMA_BASE , # [doc = "0x04 - "]
pub dma_length : DMA_LENGTH , # [doc = "0x08 - "]
pub dma_enable : DMA_ENABLE , # [doc = "0x0c - "]
pub dma_done : DMA_DONE , # [doc = "0x10 - "]
pub dma_loop : DMA_LOOP , # [doc = "0x14 - "]
pub dma_offset : DMA_OFFSET , } # [doc = "DMA_BASE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_base::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_base::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_base`]
module"]
pub type DMA_BASE = crate :: Reg < dma_base :: DMA_BASE_SPEC > ; # [doc = ""]
pub mod dma_base { # [doc = "Register `DMA_BASE` reader"]
pub type R = crate :: R < DMA_BASE_SPEC > ; # [doc = "Register `DMA_BASE` writer"]
pub type W = crate :: W < DMA_BASE_SPEC > ; # [doc = "Field `dma_base` reader - "]
pub type DMA_BASE_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_base` writer - "]
pub type DMA_BASE_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_base (& self) -> DMA_BASE_R { DMA_BASE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_base (& mut self) -> DMA_BASE_W < DMA_BASE_SPEC , 0 > { DMA_BASE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_base::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_base::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_BASE_SPEC ; impl crate :: RegisterSpec for DMA_BASE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_base::R`](R) reader structure"]
impl crate :: Readable for DMA_BASE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_base::W`](W) writer structure"]
impl crate :: Writable for DMA_BASE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_BASE to value 0x40c0_0000"]
impl crate :: Resettable for DMA_BASE_SPEC { const RESET_VALUE : Self :: Ux = 0x40c0_0000 ; } } # [doc = "DMA_LENGTH (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_length::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_length::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_length`]
module"]
pub type DMA_LENGTH = crate :: Reg < dma_length :: DMA_LENGTH_SPEC > ; # [doc = ""]
pub mod dma_length { # [doc = "Register `DMA_LENGTH` reader"]
pub type R = crate :: R < DMA_LENGTH_SPEC > ; # [doc = "Register `DMA_LENGTH` writer"]
pub type W = crate :: W < DMA_LENGTH_SPEC > ; # [doc = "Field `dma_length` reader - "]
pub type DMA_LENGTH_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_length` writer - "]
pub type DMA_LENGTH_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_length (& self) -> DMA_LENGTH_R { DMA_LENGTH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_length (& mut self) -> DMA_LENGTH_W < DMA_LENGTH_SPEC , 0 > { DMA_LENGTH_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_length::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_length::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_LENGTH_SPEC ; impl crate :: RegisterSpec for DMA_LENGTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_length::R`](R) reader structure"]
impl crate :: Readable for DMA_LENGTH_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_length::W`](W) writer structure"]
impl crate :: Writable for DMA_LENGTH_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_LENGTH to value 0x0001_f2c0"]
impl crate :: Resettable for DMA_LENGTH_SPEC { const RESET_VALUE : Self :: Ux = 0x0001_f2c0 ; } } # [doc = "DMA_ENABLE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_enable`]
module"]
pub type DMA_ENABLE = crate :: Reg < dma_enable :: DMA_ENABLE_SPEC > ; # [doc = ""]
pub mod dma_enable { # [doc = "Register `DMA_ENABLE` reader"]
pub type R = crate :: R < DMA_ENABLE_SPEC > ; # [doc = "Register `DMA_ENABLE` writer"]
pub type W = crate :: W < DMA_ENABLE_SPEC > ; # [doc = "Field `dma_enable` reader - "]
pub type DMA_ENABLE_R = crate :: BitReader ; # [doc = "Field `dma_enable` writer - "]
pub type DMA_ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_enable (& self) -> DMA_ENABLE_R { DMA_ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_enable (& mut self) -> DMA_ENABLE_W < DMA_ENABLE_SPEC , 0 > { DMA_ENABLE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_ENABLE_SPEC ; impl crate :: RegisterSpec for DMA_ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_enable::R`](R) reader structure"]
impl crate :: Readable for DMA_ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_enable::W`](W) writer structure"]
impl crate :: Writable for DMA_ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_ENABLE to value 0"]
impl crate :: Resettable for DMA_ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DMA_DONE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_done::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_done::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_done`]
module"]
pub type DMA_DONE = crate :: Reg < dma_done :: DMA_DONE_SPEC > ; # [doc = ""]
pub mod dma_done { # [doc = "Register `DMA_DONE` reader"]
pub type R = crate :: R < DMA_DONE_SPEC > ; # [doc = "Register `DMA_DONE` writer"]
pub type W = crate :: W < DMA_DONE_SPEC > ; # [doc = "Field `dma_done` reader - "]
pub type DMA_DONE_R = crate :: BitReader ; # [doc = "Field `dma_done` writer - "]
pub type DMA_DONE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_done (& self) -> DMA_DONE_R { DMA_DONE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_done (& mut self) -> DMA_DONE_W < DMA_DONE_SPEC , 0 > { DMA_DONE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_done::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_done::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_DONE_SPEC ; impl crate :: RegisterSpec for DMA_DONE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_done::R`](R) reader structure"]
impl crate :: Readable for DMA_DONE_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_done::W`](W) writer structure"]
impl crate :: Writable for DMA_DONE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_DONE to value 0"]
impl crate :: Resettable for DMA_DONE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DMA_LOOP (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_loop::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_loop::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_loop`]
module"]
pub type DMA_LOOP = crate :: Reg < dma_loop :: DMA_LOOP_SPEC > ; # [doc = ""]
pub mod dma_loop { # [doc = "Register `DMA_LOOP` reader"]
pub type R = crate :: R < DMA_LOOP_SPEC > ; # [doc = "Register `DMA_LOOP` writer"]
pub type W = crate :: W < DMA_LOOP_SPEC > ; # [doc = "Field `dma_loop` reader - "]
pub type DMA_LOOP_R = crate :: BitReader ; # [doc = "Field `dma_loop` writer - "]
pub type DMA_LOOP_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn dma_loop (& self) -> DMA_LOOP_R { DMA_LOOP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn dma_loop (& mut self) -> DMA_LOOP_W < DMA_LOOP_SPEC , 0 > { DMA_LOOP_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_loop::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_loop::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_LOOP_SPEC ; impl crate :: RegisterSpec for DMA_LOOP_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_loop::R`](R) reader structure"]
impl crate :: Readable for DMA_LOOP_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_loop::W`](W) writer structure"]
impl crate :: Writable for DMA_LOOP_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_LOOP to value 0x01"]
impl crate :: Resettable for DMA_LOOP_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "DMA_OFFSET (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_offset::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_offset::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`dma_offset`]
module"]
pub type DMA_OFFSET = crate :: Reg < dma_offset :: DMA_OFFSET_SPEC > ; # [doc = ""]
pub mod dma_offset { # [doc = "Register `DMA_OFFSET` reader"]
pub type R = crate :: R < DMA_OFFSET_SPEC > ; # [doc = "Register `DMA_OFFSET` writer"]
pub type W = crate :: W < DMA_OFFSET_SPEC > ; # [doc = "Field `dma_offset` reader - "]
pub type DMA_OFFSET_R = crate :: FieldReader < u32 > ; # [doc = "Field `dma_offset` writer - "]
pub type DMA_OFFSET_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 32 , O , u32 > ; impl R { # [doc = "Bits 0:31"]
# [inline (always)]
pub fn dma_offset (& self) -> DMA_OFFSET_R { DMA_OFFSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31"]
# [inline (always)]
# [must_use]
pub fn dma_offset (& mut self) -> DMA_OFFSET_W < DMA_OFFSET_SPEC , 0 > { DMA_OFFSET_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma_offset::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma_offset::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DMA_OFFSET_SPEC ; impl crate :: RegisterSpec for DMA_OFFSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`dma_offset::R`](R) reader structure"]
impl crate :: Readable for DMA_OFFSET_SPEC { } # [doc = "`write(|w| ..)` method takes [`dma_offset::W`](W) writer structure"]
impl crate :: Writable for DMA_OFFSET_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DMA_OFFSET to value 0"]
impl crate :: Resettable for DMA_OFFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub struct VIDEO_FRAMEBUFFER_VTG { _marker : PhantomData < * const () > } unsafe impl Send for VIDEO_FRAMEBUFFER_VTG { } impl VIDEO_FRAMEBUFFER_VTG { # [doc = r"Pointer to the register block"]
pub const PTR : * const video_framebuffer_vtg :: RegisterBlock = 0xf000_3800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const video_framebuffer_vtg :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for VIDEO_FRAMEBUFFER_VTG { type Target = video_framebuffer_vtg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VIDEO_FRAMEBUFFER_VTG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VIDEO_FRAMEBUFFER_VTG") . finish () } } # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub mod video_framebuffer_vtg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - "]
pub enable : ENABLE , # [doc = "0x04 - "]
pub hres : HRES , # [doc = "0x08 - "]
pub hsync_start : HSYNC_START , # [doc = "0x0c - "]
pub hsync_end : HSYNC_END , # [doc = "0x10 - "]
pub hscan : HSCAN , # [doc = "0x14 - "]
pub vres : VRES , # [doc = "0x18 - "]
pub vsync_start : VSYNC_START , # [doc = "0x1c - "]
pub vsync_end : VSYNC_END , # [doc = "0x20 - "]
pub vscan : VSCAN , } # [doc = "ENABLE (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`enable`]
module"]
pub type ENABLE = crate :: Reg < enable :: ENABLE_SPEC > ; # [doc = ""]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < ENABLE_SPEC > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < ENABLE_SPEC > ; # [doc = "Field `enable` reader - "]
pub type ENABLE_R = crate :: BitReader ; # [doc = "Field `enable` writer - "]
pub type ENABLE_W < 'a , REG , const O : u8 > = crate :: BitWriter < 'a , REG , O > ; impl R { # [doc = "Bit 0"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < ENABLE_SPEC , 0 > { ENABLE_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`enable::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ENABLE_SPEC ; impl crate :: RegisterSpec for ENABLE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for ENABLE_SPEC { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for ENABLE_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0x01"]
impl crate :: Resettable for ENABLE_SPEC { const RESET_VALUE : Self :: Ux = 0x01 ; } } # [doc = "HRES (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hres::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hres::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hres`]
module"]
pub type HRES = crate :: Reg < hres :: HRES_SPEC > ; # [doc = ""]
pub mod hres { # [doc = "Register `HRES` reader"]
pub type R = crate :: R < HRES_SPEC > ; # [doc = "Register `HRES` writer"]
pub type W = crate :: W < HRES_SPEC > ; # [doc = "Field `hres` reader - "]
pub type HRES_R = crate :: FieldReader < u16 > ; # [doc = "Field `hres` writer - "]
pub type HRES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hres (& self) -> HRES_R { HRES_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hres (& mut self) -> HRES_W < HRES_SPEC , 0 > { HRES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hres::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hres::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HRES_SPEC ; impl crate :: RegisterSpec for HRES_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hres::R`](R) reader structure"]
impl crate :: Readable for HRES_SPEC { } # [doc = "`write(|w| ..)` method takes [`hres::W`](W) writer structure"]
impl crate :: Writable for HRES_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HRES to value 0x010a"]
impl crate :: Resettable for HRES_SPEC { const RESET_VALUE : Self :: Ux = 0x010a ; } } # [doc = "HSYNC_START (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_start::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_start::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hsync_start`]
module"]
pub type HSYNC_START = crate :: Reg < hsync_start :: HSYNC_START_SPEC > ; # [doc = ""]
pub mod hsync_start { # [doc = "Register `HSYNC_START` reader"]
pub type R = crate :: R < HSYNC_START_SPEC > ; # [doc = "Register `HSYNC_START` writer"]
pub type W = crate :: W < HSYNC_START_SPEC > ; # [doc = "Field `hsync_start` reader - "]
pub type HSYNC_START_R = crate :: FieldReader < u16 > ; # [doc = "Field `hsync_start` writer - "]
pub type HSYNC_START_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hsync_start (& self) -> HSYNC_START_R { HSYNC_START_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hsync_start (& mut self) -> HSYNC_START_W < HSYNC_START_SPEC , 0 > { HSYNC_START_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_start::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_start::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSYNC_START_SPEC ; impl crate :: RegisterSpec for HSYNC_START_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hsync_start::R`](R) reader structure"]
impl crate :: Readable for HSYNC_START_SPEC { } # [doc = "`write(|w| ..)` method takes [`hsync_start::W`](W) writer structure"]
impl crate :: Writable for HSYNC_START_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSYNC_START to value 0x0112"]
impl crate :: Resettable for HSYNC_START_SPEC { const RESET_VALUE : Self :: Ux = 0x0112 ; } } # [doc = "HSYNC_END (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hsync_end`]
module"]
pub type HSYNC_END = crate :: Reg < hsync_end :: HSYNC_END_SPEC > ; # [doc = ""]
pub mod hsync_end { # [doc = "Register `HSYNC_END` reader"]
pub type R = crate :: R < HSYNC_END_SPEC > ; # [doc = "Register `HSYNC_END` writer"]
pub type W = crate :: W < HSYNC_END_SPEC > ; # [doc = "Field `hsync_end` reader - "]
pub type HSYNC_END_R = crate :: FieldReader < u16 > ; # [doc = "Field `hsync_end` writer - "]
pub type HSYNC_END_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hsync_end (& self) -> HSYNC_END_R { HSYNC_END_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hsync_end (& mut self) -> HSYNC_END_W < HSYNC_END_SPEC , 0 > { HSYNC_END_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hsync_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hsync_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSYNC_END_SPEC ; impl crate :: RegisterSpec for HSYNC_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hsync_end::R`](R) reader structure"]
impl crate :: Readable for HSYNC_END_SPEC { } # [doc = "`write(|w| ..)` method takes [`hsync_end::W`](W) writer structure"]
impl crate :: Writable for HSYNC_END_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSYNC_END to value 0x0132"]
impl crate :: Resettable for HSYNC_END_SPEC { const RESET_VALUE : Self :: Ux = 0x0132 ; } } # [doc = "HSCAN (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hscan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`hscan`]
module"]
pub type HSCAN = crate :: Reg < hscan :: HSCAN_SPEC > ; # [doc = ""]
pub mod hscan { # [doc = "Register `HSCAN` reader"]
pub type R = crate :: R < HSCAN_SPEC > ; # [doc = "Register `HSCAN` writer"]
pub type W = crate :: W < HSCAN_SPEC > ; # [doc = "Field `hscan` reader - "]
pub type HSCAN_R = crate :: FieldReader < u16 > ; # [doc = "Field `hscan` writer - "]
pub type HSCAN_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn hscan (& self) -> HSCAN_R { HSCAN_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn hscan (& mut self) -> HSCAN_W < HSCAN_SPEC , 0 > { HSCAN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`hscan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`hscan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct HSCAN_SPEC ; impl crate :: RegisterSpec for HSCAN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`hscan::R`](R) reader structure"]
impl crate :: Readable for HSCAN_SPEC { } # [doc = "`write(|w| ..)` method takes [`hscan::W`](W) writer structure"]
impl crate :: Writable for HSCAN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HSCAN to value 0x0153"]
impl crate :: Resettable for HSCAN_SPEC { const RESET_VALUE : Self :: Ux = 0x0153 ; } } # [doc = "VRES (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vres::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vres::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vres`]
module"]
pub type VRES = crate :: Reg < vres :: VRES_SPEC > ; # [doc = ""]
pub mod vres { # [doc = "Register `VRES` reader"]
pub type R = crate :: R < VRES_SPEC > ; # [doc = "Register `VRES` writer"]
pub type W = crate :: W < VRES_SPEC > ; # [doc = "Field `vres` reader - "]
pub type VRES_R = crate :: FieldReader < u16 > ; # [doc = "Field `vres` writer - "]
pub type VRES_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vres (& self) -> VRES_R { VRES_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vres (& mut self) -> VRES_W < VRES_SPEC , 0 > { VRES_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vres::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vres::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VRES_SPEC ; impl crate :: RegisterSpec for VRES_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vres::R`](R) reader structure"]
impl crate :: Readable for VRES_SPEC { } # [doc = "`write(|w| ..)` method takes [`vres::W`](W) writer structure"]
impl crate :: Writable for VRES_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VRES to value 0xf0"]
impl crate :: Resettable for VRES_SPEC { const RESET_VALUE : Self :: Ux = 0xf0 ; } } # [doc = "VSYNC_START (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_start::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_start::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_start`]
module"]
pub type VSYNC_START = crate :: Reg < vsync_start :: VSYNC_START_SPEC > ; # [doc = ""]
pub mod vsync_start { # [doc = "Register `VSYNC_START` reader"]
pub type R = crate :: R < VSYNC_START_SPEC > ; # [doc = "Register `VSYNC_START` writer"]
pub type W = crate :: W < VSYNC_START_SPEC > ; # [doc = "Field `vsync_start` reader - "]
pub type VSYNC_START_R = crate :: FieldReader < u16 > ; # [doc = "Field `vsync_start` writer - "]
pub type VSYNC_START_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vsync_start (& self) -> VSYNC_START_R { VSYNC_START_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vsync_start (& mut self) -> VSYNC_START_W < VSYNC_START_SPEC , 0 > { VSYNC_START_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_start::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_start::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_START_SPEC ; impl crate :: RegisterSpec for VSYNC_START_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_start::R`](R) reader structure"]
impl crate :: Readable for VSYNC_START_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_start::W`](W) writer structure"]
impl crate :: Writable for VSYNC_START_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_START to value 0xf1"]
impl crate :: Resettable for VSYNC_START_SPEC { const RESET_VALUE : Self :: Ux = 0xf1 ; } } # [doc = "VSYNC_END (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_end::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_end::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vsync_end`]
module"]
pub type VSYNC_END = crate :: Reg < vsync_end :: VSYNC_END_SPEC > ; # [doc = ""]
pub mod vsync_end { # [doc = "Register `VSYNC_END` reader"]
pub type R = crate :: R < VSYNC_END_SPEC > ; # [doc = "Register `VSYNC_END` writer"]
pub type W = crate :: W < VSYNC_END_SPEC > ; # [doc = "Field `vsync_end` reader - "]
pub type VSYNC_END_R = crate :: FieldReader < u16 > ; # [doc = "Field `vsync_end` writer - "]
pub type VSYNC_END_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vsync_end (& self) -> VSYNC_END_R { VSYNC_END_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vsync_end (& mut self) -> VSYNC_END_W < VSYNC_END_SPEC , 0 > { VSYNC_END_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vsync_end::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vsync_end::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSYNC_END_SPEC ; impl crate :: RegisterSpec for VSYNC_END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vsync_end::R`](R) reader structure"]
impl crate :: Readable for VSYNC_END_SPEC { } # [doc = "`write(|w| ..)` method takes [`vsync_end::W`](W) writer structure"]
impl crate :: Writable for VSYNC_END_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSYNC_END to value 0xf9"]
impl crate :: Resettable for VSYNC_END_SPEC { const RESET_VALUE : Self :: Ux = 0xf9 ; } } # [doc = "VSCAN (rw) register accessor: \n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vscan::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vscan::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`vscan`]
module"]
pub type VSCAN = crate :: Reg < vscan :: VSCAN_SPEC > ; # [doc = ""]
pub mod vscan { # [doc = "Register `VSCAN` reader"]
pub type R = crate :: R < VSCAN_SPEC > ; # [doc = "Register `VSCAN` writer"]
pub type W = crate :: W < VSCAN_SPEC > ; # [doc = "Field `vscan` reader - "]
pub type VSCAN_R = crate :: FieldReader < u16 > ; # [doc = "Field `vscan` writer - "]
pub type VSCAN_W < 'a , REG , const O : u8 > = crate :: FieldWriter < 'a , REG , 12 , O , u16 > ; impl R { # [doc = "Bits 0:11"]
# [inline (always)]
pub fn vscan (& self) -> VSCAN_R { VSCAN_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11"]
# [inline (always)]
# [must_use]
pub fn vscan (& mut self) -> VSCAN_W < VSCAN_SPEC , 0 > { VSCAN_W :: new (self) } # [doc = r" Writes raw bits to the register."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . bits = bits ; self } } # [doc = "\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`vscan::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`vscan::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct VSCAN_SPEC ; impl crate :: RegisterSpec for VSCAN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [`vscan::R`](R) reader structure"]
impl crate :: Readable for VSCAN_SPEC { } # [doc = "`write(|w| ..)` method takes [`vscan::W`](W) writer structure"]
impl crate :: Writable for VSCAN_SPEC { const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VSCAN to value 0x0117"]
impl crate :: Resettable for VSCAN_SPEC { const RESET_VALUE : Self :: Ux = 0x0117 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "CTRL"]
pub CTRL : CTRL , # [doc = "IDENTIFIER_MEM"]
pub IDENTIFIER_MEM : IDENTIFIER_MEM , # [doc = "MAIN"]
pub MAIN : MAIN , # [doc = "SDRAM"]
pub SDRAM : SDRAM , # [doc = "TIMER0"]
pub TIMER0 : TIMER0 , # [doc = "UART"]
pub UART : UART , # [doc = "VIDEO_FRAMEBUFFER"]
pub VIDEO_FRAMEBUFFER : VIDEO_FRAMEBUFFER , # [doc = "VIDEO_FRAMEBUFFER_VTG"]
pub VIDEO_FRAMEBUFFER_VTG : VIDEO_FRAMEBUFFER_VTG , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { CTRL : CTRL { _marker : PhantomData } , IDENTIFIER_MEM : IDENTIFIER_MEM { _marker : PhantomData } , MAIN : MAIN { _marker : PhantomData } , SDRAM : SDRAM { _marker : PhantomData } , TIMER0 : TIMER0 { _marker : PhantomData } , UART : UART { _marker : PhantomData } , VIDEO_FRAMEBUFFER : VIDEO_FRAMEBUFFER { _marker : PhantomData } , VIDEO_FRAMEBUFFER_VTG : VIDEO_FRAMEBUFFER_VTG { _marker : PhantomData } , } } }